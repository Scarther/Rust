//! # Network Behavior Monitor for Malware Analysis
//!
//! This tool monitors network traffic to detect malicious communication patterns.
//! Network analysis is critical for identifying Command & Control (C2) channels,
//! data exfiltration attempts, and other malicious network behaviors.
//!
//! ## Malware Network Behaviors
//!
//! **Command & Control (C2):**
//! - Regular beaconing patterns (fixed intervals)
//! - DNS tunneling (data encoded in DNS queries)
//! - HTTP/HTTPS callbacks to hardcoded IPs or domains
//! - Use of non-standard ports
//!
//! **Data Exfiltration:**
//! - Large outbound data transfers
//! - Data encoded in DNS TXT records
//! - Steganography in images/files
//! - Encrypted channels to unknown destinations
//!
//! **Lateral Movement:**
//! - Internal network scanning
//! - SMB/SSH connections to internal hosts
//! - Pass-the-hash/Pass-the-ticket attacks
//!
//! **Indicators of Compromise (IoCs):**
//! - Known malicious IPs and domains
//! - Unusual User-Agent strings
//! - Suspicious TLS certificates
//! - Anomalous traffic patterns
//!
//! ## DEFENSIVE USE ONLY
//! This tool is designed for analyzing network traffic in controlled environments.

use anyhow::{Context, Result};
use chrono::{DateTime, Local, Utc};
use clap::{Parser, ValueEnum};
use colored::*;
use pnet::datalink::{self, Channel::Ethernet, NetworkInterface};
use pnet::packet::ethernet::{EtherTypes, EthernetPacket};
use pnet::packet::ip::IpNextHeaderProtocols;
use pnet::packet::ipv4::Ipv4Packet;
use pnet::packet::ipv6::Ipv6Packet;
use pnet::packet::tcp::TcpPacket;
use pnet::packet::udp::UdpPacket;
use pnet::packet::Packet;
use regex::Regex;
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet, VecDeque};
use std::fs::File;
use std::io::{BufWriter, Write};
use std::net::{IpAddr, Ipv4Addr};
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;
use std::time::{Duration, Instant};
use uuid::Uuid;

/// Network Behavior Monitor - Malware Analysis Tool
///
/// Monitors network traffic to detect malicious communication patterns.
#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    /// Network interface to monitor
    #[arg(short, long)]
    interface: Option<String>,

    /// Output format
    #[arg(short, long, value_enum, default_value = "text")]
    format: OutputFormat,

    /// Output file for captured data
    #[arg(short = 'o', long)]
    output: Option<String>,

    /// Only show suspicious traffic
    #[arg(long)]
    suspicious_only: bool,

    /// Filter by protocol (tcp, udp, icmp)
    #[arg(short = 'p', long)]
    protocol: Option<String>,

    /// Filter by port
    #[arg(long)]
    port: Option<u16>,

    /// Filter by destination IP/network
    #[arg(long)]
    dest: Option<String>,

    /// Capture duration in seconds (0 = continuous)
    #[arg(short = 'd', long, default_value = "60")]
    duration: u64,

    /// Enable C2 detection heuristics
    #[arg(long)]
    detect_c2: bool,

    /// Enable DNS analysis
    #[arg(long)]
    analyze_dns: bool,

    /// Enable HTTP analysis
    #[arg(long)]
    analyze_http: bool,

    /// List available interfaces and exit
    #[arg(short = 'l', long)]
    list_interfaces: bool,

    /// Run in demo mode (simulated traffic)
    #[arg(long)]
    demo: bool,

    /// Verbose output
    #[arg(short, long)]
    verbose: bool,
}

/// Output format
#[derive(Debug, Clone, ValueEnum)]
enum OutputFormat {
    Text,
    Json,
    Csv,
}

/// Protocol types
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
enum Protocol {
    Tcp,
    Udp,
    Icmp,
    Other(u8),
}

impl std::fmt::Display for Protocol {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Protocol::Tcp => write!(f, "TCP"),
            Protocol::Udp => write!(f, "UDP"),
            Protocol::Icmp => write!(f, "ICMP"),
            Protocol::Other(n) => write!(f, "Other({})", n),
        }
    }
}

/// Represents a network packet
#[derive(Debug, Clone, Serialize, Deserialize)]
struct NetworkPacket {
    /// Unique packet ID
    id: String,
    /// Timestamp
    timestamp: String,
    /// Source IP
    src_ip: String,
    /// Destination IP
    dst_ip: String,
    /// Source port (for TCP/UDP)
    src_port: Option<u16>,
    /// Destination port (for TCP/UDP)
    dst_port: Option<u16>,
    /// Protocol
    protocol: String,
    /// Payload size
    payload_size: usize,
    /// TCP flags (if TCP)
    tcp_flags: Option<String>,
    /// Payload preview (hex)
    payload_preview: Option<String>,
    /// Is suspicious
    suspicious: bool,
    /// Suspicious reason
    suspicious_reason: Option<String>,
}

/// Represents a network flow (connection)
#[derive(Debug, Clone, Serialize, Deserialize)]
struct NetworkFlow {
    /// Flow ID
    id: String,
    /// Source IP
    src_ip: String,
    /// Destination IP
    dst_ip: String,
    /// Source port
    src_port: u16,
    /// Destination port
    dst_port: u16,
    /// Protocol
    protocol: String,
    /// Start time
    start_time: String,
    /// Last seen time
    last_seen: String,
    /// Total packets
    packet_count: u64,
    /// Total bytes
    byte_count: u64,
    /// Flow state
    state: FlowState,
}

/// Flow states
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
enum FlowState {
    New,
    Established,
    Closing,
    Closed,
}

/// Represents a DNS query/response
#[derive(Debug, Clone, Serialize, Deserialize)]
struct DnsEvent {
    /// Event ID
    id: String,
    /// Timestamp
    timestamp: String,
    /// Query or Response
    is_response: bool,
    /// Domain name
    domain: String,
    /// Query type (A, AAAA, TXT, MX, etc.)
    query_type: String,
    /// Response data (if response)
    response_data: Vec<String>,
    /// Source IP
    src_ip: String,
    /// Suspicious flags
    suspicious: bool,
    /// Suspicious reason
    suspicious_reason: Option<String>,
}

/// Represents an HTTP event
#[derive(Debug, Clone, Serialize, Deserialize)]
struct HttpEvent {
    /// Event ID
    id: String,
    /// Timestamp
    timestamp: String,
    /// Request or Response
    is_response: bool,
    /// HTTP method
    method: Option<String>,
    /// URL path
    path: Option<String>,
    /// Host header
    host: Option<String>,
    /// User-Agent
    user_agent: Option<String>,
    /// Status code (if response)
    status_code: Option<u16>,
    /// Content-Type
    content_type: Option<String>,
    /// Content length
    content_length: Option<usize>,
    /// Suspicious
    suspicious: bool,
    /// Suspicious reason
    suspicious_reason: Option<String>,
}

/// Detected suspicious activity
#[derive(Debug, Clone, Serialize, Deserialize)]
struct SuspiciousActivity {
    /// Activity ID
    id: String,
    /// Timestamp
    timestamp: String,
    /// Activity type
    activity_type: String,
    /// Severity (low, medium, high, critical)
    severity: String,
    /// Description
    description: String,
    /// Source IP
    src_ip: String,
    /// Destination IP
    dst_ip: String,
    /// Evidence (packet IDs, flow IDs)
    evidence: Vec<String>,
}

/// C2 detection patterns
#[derive(Debug, Clone)]
struct C2Pattern {
    name: &'static str,
    description: &'static str,
    ports: Vec<u16>,
    interval_range: Option<(u64, u64)>, // min, max seconds between beacons
    indicators: Vec<&'static str>,
}

/// Known malicious indicators
struct ThreatIntelligence {
    /// Known malicious IPs
    malicious_ips: HashSet<String>,
    /// Known malicious domains
    malicious_domains: HashSet<String>,
    /// Suspicious ports
    suspicious_ports: HashSet<u16>,
    /// Suspicious User-Agents
    suspicious_user_agents: Vec<Regex>,
}

impl Default for ThreatIntelligence {
    fn default() -> Self {
        let mut malicious_ips = HashSet::new();
        // Example known malicious IPs (for demonstration)
        malicious_ips.insert("185.234.216.0/24".to_string()); // Example range

        let mut malicious_domains = HashSet::new();
        // Example known malicious domains
        malicious_domains.insert("evil.com".to_string());
        malicious_domains.insert("malware.net".to_string());
        malicious_domains.insert("c2server.ru".to_string());

        let mut suspicious_ports = HashSet::new();
        // Common C2/backdoor ports
        suspicious_ports.insert(4444);  // Metasploit default
        suspicious_ports.insert(5555);  // Common backdoor
        suspicious_ports.insert(6666);  // Common backdoor
        suspicious_ports.insert(7777);  // Common backdoor
        suspicious_ports.insert(8888);  // Common backdoor
        suspicious_ports.insert(9999);  // Common backdoor
        suspicious_ports.insert(1337);  // Leet port
        suspicious_ports.insert(31337); // Elite backdoor
        suspicious_ports.insert(12345); // NetBus
        suspicious_ports.insert(27374); // Sub7
        suspicious_ports.insert(6667);  // IRC (sometimes C2)
        suspicious_ports.insert(6697);  // IRC SSL

        let suspicious_user_agents = vec![
            Regex::new(r"(?i)python-requests").unwrap(),
            Regex::new(r"(?i)curl/").unwrap(),
            Regex::new(r"(?i)wget/").unwrap(),
            Regex::new(r"(?i)powershell").unwrap(),
            Regex::new(r"(?i)go-http-client").unwrap(),
            Regex::new(r"^$").unwrap(), // Empty User-Agent
        ];

        Self {
            malicious_ips,
            malicious_domains,
            suspicious_ports,
            suspicious_user_agents,
        }
    }
}

/// Statistics about captured traffic
#[derive(Debug, Default, Serialize, Deserialize)]
struct TrafficStats {
    total_packets: u64,
    total_bytes: u64,
    tcp_packets: u64,
    udp_packets: u64,
    icmp_packets: u64,
    other_packets: u64,
    suspicious_packets: u64,
    unique_src_ips: HashSet<String>,
    unique_dst_ips: HashSet<String>,
    port_counts: HashMap<u16, u64>,
    start_time: String,
    end_time: String,
}

/// Beaconing detection state
struct BeaconDetector {
    /// Connection intervals: (src_ip, dst_ip, dst_port) -> list of timestamps
    intervals: HashMap<(String, String, u16), VecDeque<DateTime<Utc>>>,
    /// Detected beacons
    detected: Vec<SuspiciousActivity>,
}

impl BeaconDetector {
    fn new() -> Self {
        Self {
            intervals: HashMap::new(),
            detected: Vec::new(),
        }
    }

    /// Add a connection event
    fn add_connection(&mut self, src_ip: &str, dst_ip: &str, dst_port: u16, timestamp: DateTime<Utc>) {
        let key = (src_ip.to_string(), dst_ip.to_string(), dst_port);
        let entry = self.intervals.entry(key).or_insert_with(VecDeque::new);

        entry.push_back(timestamp);

        // Keep only last 20 connections
        while entry.len() > 20 {
            entry.pop_front();
        }
    }

    /// Analyze for beaconing patterns
    fn analyze(&mut self) -> Vec<SuspiciousActivity> {
        let mut activities = Vec::new();

        for ((src_ip, dst_ip, dst_port), timestamps) in &self.intervals {
            if timestamps.len() < 5 {
                continue;
            }

            // Calculate intervals between connections
            let mut intervals: Vec<i64> = Vec::new();
            for i in 1..timestamps.len() {
                let diff = (timestamps[i] - timestamps[i - 1]).num_seconds();
                intervals.push(diff);
            }

            // Check for regular intervals (beaconing)
            if intervals.len() >= 4 {
                let avg: f64 = intervals.iter().map(|&i| i as f64).sum::<f64>() / intervals.len() as f64;
                let variance: f64 = intervals.iter()
                    .map(|&i| (i as f64 - avg).powi(2))
                    .sum::<f64>() / intervals.len() as f64;
                let std_dev = variance.sqrt();

                // If standard deviation is low relative to average, it's regular beaconing
                if avg > 10.0 && std_dev < avg * 0.2 {
                    activities.push(SuspiciousActivity {
                        id: Uuid::new_v4().to_string(),
                        timestamp: Local::now().format("%Y-%m-%d %H:%M:%S").to_string(),
                        activity_type: "c2_beaconing".to_string(),
                        severity: "high".to_string(),
                        description: format!(
                            "Regular beaconing detected: ~{:.0}s interval (std_dev: {:.1}s)",
                            avg, std_dev
                        ),
                        src_ip: src_ip.clone(),
                        dst_ip: format!("{}:{}", dst_ip, dst_port),
                        evidence: vec![format!("{} connections analyzed", timestamps.len())],
                    });
                }
            }
        }

        activities
    }
}

/// Main network monitor
struct NetworkMonitor {
    args: Args,
    packets: Vec<NetworkPacket>,
    flows: HashMap<String, NetworkFlow>,
    dns_events: Vec<DnsEvent>,
    http_events: Vec<HttpEvent>,
    suspicious_activities: Vec<SuspiciousActivity>,
    stats: TrafficStats,
    threat_intel: ThreatIntelligence,
    beacon_detector: BeaconDetector,
}

impl NetworkMonitor {
    fn new(args: Args) -> Self {
        Self {
            args,
            packets: Vec::new(),
            flows: HashMap::new(),
            dns_events: Vec::new(),
            http_events: Vec::new(),
            suspicious_activities: Vec::new(),
            stats: TrafficStats::default(),
            threat_intel: ThreatIntelligence::default(),
            beacon_detector: BeaconDetector::new(),
        }
    }

    /// List available network interfaces
    fn list_interfaces() {
        println!("{}", "Available network interfaces:".bold());
        for iface in datalink::interfaces() {
            let status = if iface.is_up() { "UP".green() } else { "DOWN".red() };
            let ips: Vec<String> = iface.ips.iter().map(|ip| ip.to_string()).collect();
            println!("  {} [{}] - {}", iface.name.cyan(), status, ips.join(", "));
        }
    }

    /// Find interface by name
    fn find_interface(name: &str) -> Option<NetworkInterface> {
        datalink::interfaces()
            .into_iter()
            .find(|iface| iface.name == name)
    }

    /// Get the first suitable interface
    fn get_default_interface() -> Option<NetworkInterface> {
        datalink::interfaces()
            .into_iter()
            .find(|iface| {
                iface.is_up() && !iface.is_loopback() && !iface.ips.is_empty()
            })
    }

    /// Check if an IP is suspicious
    fn is_suspicious_ip(&self, ip: &str) -> bool {
        // Check against known malicious IPs
        self.threat_intel.malicious_ips.contains(ip)
    }

    /// Check if a port is suspicious
    fn is_suspicious_port(&self, port: u16) -> bool {
        self.threat_intel.suspicious_ports.contains(&port)
    }

    /// Check if a domain is suspicious
    fn is_suspicious_domain(&self, domain: &str) -> (bool, Option<String>) {
        // Check against known malicious domains
        if self.threat_intel.malicious_domains.iter().any(|d| domain.contains(d)) {
            return (true, Some("Known malicious domain".to_string()));
        }

        // Check for DGA-like patterns (random-looking domains)
        let consonants: Vec<char> = domain.chars()
            .filter(|c| "bcdfghjklmnpqrstvwxyz".contains(*c))
            .collect();
        let vowels: Vec<char> = domain.chars()
            .filter(|c| "aeiou".contains(*c))
            .collect();

        // High consonant-to-vowel ratio might indicate DGA
        if consonants.len() > 10 && vowels.len() > 0 {
            let ratio = consonants.len() as f64 / vowels.len() as f64;
            if ratio > 5.0 {
                return (true, Some("Possible DGA domain (high consonant ratio)".to_string()));
            }
        }

        // Very long subdomains might indicate DNS tunneling
        let parts: Vec<&str> = domain.split('.').collect();
        if parts.iter().any(|p| p.len() > 30) {
            return (true, Some("Possible DNS tunneling (long subdomain)".to_string()));
        }

        (false, None)
    }

    /// Analyze a packet for suspicious behavior
    fn analyze_packet(&mut self, packet: &mut NetworkPacket) {
        let mut reasons = Vec::new();

        // Check for suspicious destination IP
        if self.is_suspicious_ip(&packet.dst_ip) {
            reasons.push("Known malicious IP");
        }

        // Check for suspicious port
        if let Some(port) = packet.dst_port {
            if self.is_suspicious_port(port) {
                reasons.push("Suspicious port");
            }
        }

        // Check for large outbound data (potential exfiltration)
        if packet.payload_size > 10000 {
            reasons.push("Large payload (potential data exfiltration)");
        }

        // Check for empty payload on established connection (C2 heartbeat)
        if packet.payload_size == 0 && packet.tcp_flags.as_deref() == Some("ACK") {
            // This alone isn't suspicious, but track it for pattern analysis
        }

        if !reasons.is_empty() {
            packet.suspicious = true;
            packet.suspicious_reason = Some(reasons.join("; "));
            self.stats.suspicious_packets += 1;
        }
    }

    /// Parse DNS payload
    fn parse_dns(&mut self, payload: &[u8], src_ip: &str, dst_ip: &str) {
        // Simple DNS parsing (for demonstration)
        // In production, use a proper DNS parsing library

        if payload.len() < 12 {
            return;
        }

        // DNS header: ID (2) + Flags (2) + QDCOUNT (2) + ANCOUNT (2) + NSCOUNT (2) + ARCOUNT (2)
        let flags = u16::from_be_bytes([payload[2], payload[3]]);
        let is_response = (flags & 0x8000) != 0;
        let qd_count = u16::from_be_bytes([payload[4], payload[5]]) as usize;

        if qd_count == 0 {
            return;
        }

        // Parse question section (simplified)
        let mut offset = 12;
        let mut domain_parts = Vec::new();

        while offset < payload.len() {
            let len = payload[offset] as usize;
            if len == 0 {
                break;
            }
            if offset + 1 + len > payload.len() {
                break;
            }
            if let Ok(part) = std::str::from_utf8(&payload[offset + 1..offset + 1 + len]) {
                domain_parts.push(part.to_string());
            }
            offset += 1 + len;
        }

        let domain = domain_parts.join(".");
        if domain.is_empty() {
            return;
        }

        let (suspicious, reason) = self.is_suspicious_domain(&domain);

        let dns_event = DnsEvent {
            id: Uuid::new_v4().to_string(),
            timestamp: Local::now().format("%Y-%m-%d %H:%M:%S").to_string(),
            is_response,
            domain: domain.clone(),
            query_type: "A".to_string(), // Simplified
            response_data: Vec::new(),
            src_ip: src_ip.to_string(),
            suspicious,
            suspicious_reason: reason,
        };

        if self.args.verbose {
            let dir = if is_response { "<-" } else { "->" };
            println!("  {} DNS {} {}",
                dir.cyan(),
                domain,
                if suspicious { "[SUSPICIOUS]".red().to_string() } else { "".to_string() }
            );
        }

        if suspicious {
            self.suspicious_activities.push(SuspiciousActivity {
                id: Uuid::new_v4().to_string(),
                timestamp: dns_event.timestamp.clone(),
                activity_type: "suspicious_dns".to_string(),
                severity: "medium".to_string(),
                description: dns_event.suspicious_reason.clone().unwrap_or_default(),
                src_ip: src_ip.to_string(),
                dst_ip: dst_ip.to_string(),
                evidence: vec![format!("Domain: {}", domain)],
            });
        }

        self.dns_events.push(dns_event);
    }

    /// Parse HTTP payload
    fn parse_http(&mut self, payload: &[u8], src_ip: &str, dst_ip: &str) {
        if payload.len() < 16 {
            return;
        }

        // Try to parse as HTTP request
        let mut headers = [httparse::EMPTY_HEADER; 64];
        let mut req = httparse::Request::new(&mut headers);

        if let Ok(httparse::Status::Complete(_)) = req.parse(payload) {
            let method = req.method.map(String::from);
            let path = req.path.map(String::from);

            let mut host = None;
            let mut user_agent = None;

            for header in req.headers.iter() {
                match header.name.to_lowercase().as_str() {
                    "host" => host = std::str::from_utf8(header.value).ok().map(String::from),
                    "user-agent" => user_agent = std::str::from_utf8(header.value).ok().map(String::from),
                    _ => {}
                }
            }

            // Check for suspicious User-Agent
            let suspicious = user_agent.as_ref().map(|ua| {
                self.threat_intel.suspicious_user_agents.iter().any(|re| re.is_match(ua))
            }).unwrap_or(false);

            let http_event = HttpEvent {
                id: Uuid::new_v4().to_string(),
                timestamp: Local::now().format("%Y-%m-%d %H:%M:%S").to_string(),
                is_response: false,
                method,
                path,
                host,
                user_agent: user_agent.clone(),
                status_code: None,
                content_type: None,
                content_length: None,
                suspicious,
                suspicious_reason: if suspicious {
                    Some("Suspicious User-Agent".to_string())
                } else {
                    None
                },
            };

            if self.args.verbose {
                println!("  {} HTTP {} {} {}",
                    "->".green(),
                    http_event.method.as_deref().unwrap_or("?"),
                    http_event.path.as_deref().unwrap_or("/"),
                    if suspicious { "[SUSPICIOUS]".red().to_string() } else { "".to_string() }
                );
            }

            if suspicious {
                self.suspicious_activities.push(SuspiciousActivity {
                    id: Uuid::new_v4().to_string(),
                    timestamp: http_event.timestamp.clone(),
                    activity_type: "suspicious_http".to_string(),
                    severity: "medium".to_string(),
                    description: format!("Suspicious User-Agent: {}",
                        user_agent.unwrap_or_else(|| "(empty)".to_string())),
                    src_ip: src_ip.to_string(),
                    dst_ip: dst_ip.to_string(),
                    evidence: vec![format!("Path: {}",
                        http_event.path.as_deref().unwrap_or("/"))],
                });
            }

            self.http_events.push(http_event);
        }
    }

    /// Process an Ethernet frame
    fn process_ethernet_frame(&mut self, frame: &[u8]) {
        if let Some(ethernet) = EthernetPacket::new(frame) {
            match ethernet.get_ethertype() {
                EtherTypes::Ipv4 => {
                    if let Some(ipv4) = Ipv4Packet::new(ethernet.payload()) {
                        self.process_ipv4_packet(&ipv4);
                    }
                }
                EtherTypes::Ipv6 => {
                    if let Some(ipv6) = Ipv6Packet::new(ethernet.payload()) {
                        self.process_ipv6_packet(&ipv6);
                    }
                }
                _ => {}
            }
        }
    }

    /// Process an IPv4 packet
    fn process_ipv4_packet(&mut self, ipv4: &Ipv4Packet) {
        let src_ip = ipv4.get_source().to_string();
        let dst_ip = ipv4.get_destination().to_string();

        self.stats.unique_src_ips.insert(src_ip.clone());
        self.stats.unique_dst_ips.insert(dst_ip.clone());

        match ipv4.get_next_level_protocol() {
            IpNextHeaderProtocols::Tcp => {
                if let Some(tcp) = TcpPacket::new(ipv4.payload()) {
                    self.process_tcp_packet(&src_ip, &dst_ip, &tcp);
                }
            }
            IpNextHeaderProtocols::Udp => {
                if let Some(udp) = UdpPacket::new(ipv4.payload()) {
                    self.process_udp_packet(&src_ip, &dst_ip, &udp);
                }
            }
            IpNextHeaderProtocols::Icmp => {
                self.stats.icmp_packets += 1;
                self.stats.total_packets += 1;
            }
            _ => {
                self.stats.other_packets += 1;
                self.stats.total_packets += 1;
            }
        }
    }

    /// Process an IPv6 packet
    fn process_ipv6_packet(&mut self, ipv6: &Ipv6Packet) {
        let src_ip = ipv6.get_source().to_string();
        let dst_ip = ipv6.get_destination().to_string();

        self.stats.unique_src_ips.insert(src_ip.clone());
        self.stats.unique_dst_ips.insert(dst_ip.clone());

        // Process based on next header (simplified)
        match ipv6.get_next_header() {
            IpNextHeaderProtocols::Tcp => {
                if let Some(tcp) = TcpPacket::new(ipv6.payload()) {
                    self.process_tcp_packet(&src_ip, &dst_ip, &tcp);
                }
            }
            IpNextHeaderProtocols::Udp => {
                if let Some(udp) = UdpPacket::new(ipv6.payload()) {
                    self.process_udp_packet(&src_ip, &dst_ip, &udp);
                }
            }
            _ => {
                self.stats.other_packets += 1;
                self.stats.total_packets += 1;
            }
        }
    }

    /// Process a TCP packet
    fn process_tcp_packet(&mut self, src_ip: &str, dst_ip: &str, tcp: &TcpPacket) {
        self.stats.tcp_packets += 1;
        self.stats.total_packets += 1;
        self.stats.total_bytes += tcp.packet().len() as u64;

        let src_port = tcp.get_source();
        let dst_port = tcp.get_destination();

        *self.stats.port_counts.entry(dst_port).or_insert(0) += 1;

        // Build TCP flags string
        let mut flags = String::new();
        if tcp.get_flags() & 0x01 != 0 { flags.push_str("FIN "); }
        if tcp.get_flags() & 0x02 != 0 { flags.push_str("SYN "); }
        if tcp.get_flags() & 0x04 != 0 { flags.push_str("RST "); }
        if tcp.get_flags() & 0x08 != 0 { flags.push_str("PSH "); }
        if tcp.get_flags() & 0x10 != 0 { flags.push_str("ACK "); }
        if tcp.get_flags() & 0x20 != 0 { flags.push_str("URG "); }

        let payload = tcp.payload();
        let payload_preview = if !payload.is_empty() && payload.len() <= 32 {
            Some(hex::encode(&payload[..payload.len().min(32)]))
        } else {
            None
        };

        let mut packet = NetworkPacket {
            id: Uuid::new_v4().to_string(),
            timestamp: Local::now().format("%Y-%m-%d %H:%M:%S%.3f").to_string(),
            src_ip: src_ip.to_string(),
            dst_ip: dst_ip.to_string(),
            src_port: Some(src_port),
            dst_port: Some(dst_port),
            protocol: "TCP".to_string(),
            payload_size: payload.len(),
            tcp_flags: Some(flags.trim().to_string()),
            payload_preview,
            suspicious: false,
            suspicious_reason: None,
        };

        // Analyze for suspicious behavior
        self.analyze_packet(&mut packet);

        // Track for C2 beaconing detection
        if self.args.detect_c2 && (tcp.get_flags() & 0x02 != 0) { // SYN packet
            self.beacon_detector.add_connection(src_ip, dst_ip, dst_port, Utc::now());
        }

        // Analyze HTTP traffic
        if self.args.analyze_http && (dst_port == 80 || dst_port == 8080 || src_port == 80 || src_port == 8080) {
            self.parse_http(payload, src_ip, dst_ip);
        }

        // Print if not filtering or matches filter
        if !self.args.suspicious_only || packet.suspicious {
            self.print_packet(&packet);
        }

        self.packets.push(packet);
    }

    /// Process a UDP packet
    fn process_udp_packet(&mut self, src_ip: &str, dst_ip: &str, udp: &UdpPacket) {
        self.stats.udp_packets += 1;
        self.stats.total_packets += 1;
        self.stats.total_bytes += udp.packet().len() as u64;

        let src_port = udp.get_source();
        let dst_port = udp.get_destination();

        *self.stats.port_counts.entry(dst_port).or_insert(0) += 1;

        let payload = udp.payload();

        // Analyze DNS traffic
        if self.args.analyze_dns && (dst_port == 53 || src_port == 53) {
            self.parse_dns(payload, src_ip, dst_ip);
        }

        let mut packet = NetworkPacket {
            id: Uuid::new_v4().to_string(),
            timestamp: Local::now().format("%Y-%m-%d %H:%M:%S%.3f").to_string(),
            src_ip: src_ip.to_string(),
            dst_ip: dst_ip.to_string(),
            src_port: Some(src_port),
            dst_port: Some(dst_port),
            protocol: "UDP".to_string(),
            payload_size: payload.len(),
            tcp_flags: None,
            payload_preview: None,
            suspicious: false,
            suspicious_reason: None,
        };

        self.analyze_packet(&mut packet);

        if !self.args.suspicious_only || packet.suspicious {
            self.print_packet(&packet);
        }

        self.packets.push(packet);
    }

    /// Print a packet
    fn print_packet(&self, packet: &NetworkPacket) {
        let proto_color = match packet.protocol.as_str() {
            "TCP" => packet.protocol.green(),
            "UDP" => packet.protocol.cyan(),
            _ => packet.protocol.normal(),
        };

        let suspicious_marker = if packet.suspicious {
            format!(" {}", "[!]".red().bold())
        } else {
            String::new()
        };

        let port_info = match (packet.src_port, packet.dst_port) {
            (Some(s), Some(d)) => format!(":{}->:{}", s, d),
            _ => String::new(),
        };

        println!("{} {} {} -> {}{} ({} bytes){}",
            packet.timestamp.dimmed(),
            proto_color,
            packet.src_ip,
            packet.dst_ip,
            port_info,
            packet.payload_size,
            suspicious_marker
        );

        if packet.suspicious {
            if let Some(ref reason) = packet.suspicious_reason {
                println!("    {} {}", "->".red(), reason.yellow());
            }
        }
    }

    /// Run demo mode with simulated traffic
    fn run_demo(&mut self) -> Result<()> {
        println!("{}", "[*] Running in demo mode with simulated traffic...".yellow());

        // Simulate various types of traffic
        let demo_packets = vec![
            // Normal web traffic
            ("192.168.1.100", "93.184.216.34", 443, "TCP", 1500, false, None),
            ("192.168.1.100", "8.8.8.8", 53, "UDP", 64, false, None),

            // Suspicious traffic
            ("192.168.1.100", "185.234.216.100", 4444, "TCP", 256, true,
             Some("Suspicious port (Metasploit default)")),
            ("192.168.1.100", "10.0.0.50", 31337, "TCP", 128, true,
             Some("Suspicious port (Elite backdoor)")),

            // Potential data exfiltration
            ("192.168.1.100", "203.0.113.50", 443, "TCP", 15000, true,
             Some("Large payload (potential data exfiltration)")),

            // C2 beaconing pattern
            ("192.168.1.100", "198.51.100.1", 443, "TCP", 64, false, None),
            ("192.168.1.100", "198.51.100.1", 443, "TCP", 64, false, None),
            ("192.168.1.100", "198.51.100.1", 443, "TCP", 64, false, None),

            // Normal internal traffic
            ("192.168.1.100", "192.168.1.1", 22, "TCP", 256, false, None),
        ];

        for (src, dst, port, proto, size, suspicious, reason) in demo_packets {
            let packet = NetworkPacket {
                id: Uuid::new_v4().to_string(),
                timestamp: Local::now().format("%Y-%m-%d %H:%M:%S%.3f").to_string(),
                src_ip: src.to_string(),
                dst_ip: dst.to_string(),
                src_port: Some(12345),
                dst_port: Some(port),
                protocol: proto.to_string(),
                payload_size: size,
                tcp_flags: Some("SYN ACK".to_string()),
                payload_preview: None,
                suspicious,
                suspicious_reason: reason.map(String::from),
            };

            if suspicious {
                self.stats.suspicious_packets += 1;
            }

            if !self.args.suspicious_only || packet.suspicious {
                self.print_packet(&packet);
            }

            self.packets.push(packet);
            self.stats.total_packets += 1;
            self.stats.total_bytes += size as u64;

            std::thread::sleep(Duration::from_millis(200));
        }

        // Simulate DNS events
        println!("\n{}", "DNS Events:".bold());
        let dns_events = vec![
            ("google.com", false, None),
            ("evil.com", true, Some("Known malicious domain")),
            ("xn3kdf9sdkfj3kdf.ru", true, Some("Possible DGA domain (high consonant ratio)")),
            ("data.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.tunnel.evil.net", true,
             Some("Possible DNS tunneling (long subdomain)")),
        ];

        for (domain, suspicious, reason) in dns_events {
            let dns_event = DnsEvent {
                id: Uuid::new_v4().to_string(),
                timestamp: Local::now().format("%Y-%m-%d %H:%M:%S").to_string(),
                is_response: false,
                domain: domain.to_string(),
                query_type: "A".to_string(),
                response_data: Vec::new(),
                src_ip: "192.168.1.100".to_string(),
                suspicious,
                suspicious_reason: reason.map(String::from),
            };

            let marker = if suspicious { "[SUSPICIOUS]".red().to_string() } else { "".to_string() };
            println!("  DNS Query: {} {}", domain, marker);
            if let Some(r) = &dns_event.suspicious_reason {
                println!("    {} {}", "->".red(), r.yellow());
            }

            self.dns_events.push(dns_event);
            std::thread::sleep(Duration::from_millis(100));
        }

        Ok(())
    }

    /// Run the network monitor
    fn run(&mut self) -> Result<()> {
        println!("{}", "=".repeat(70).cyan());
        println!("{}", "  NETWORK BEHAVIOR MONITOR - Malware Analysis".cyan().bold());
        println!("{}", "  For DEFENSIVE security research only".yellow());
        println!("{}", "=".repeat(70).cyan());

        if self.args.list_interfaces {
            Self::list_interfaces();
            return Ok(());
        }

        if self.args.demo {
            self.stats.start_time = Local::now().format("%Y-%m-%d %H:%M:%S").to_string();
            self.run_demo()?;
            self.stats.end_time = Local::now().format("%Y-%m-%d %H:%M:%S").to_string();
            self.print_summary();
            return Ok(());
        }

        // Get interface
        let interface = if let Some(ref name) = self.args.interface {
            Self::find_interface(name)
                .context(format!("Interface '{}' not found", name))?
        } else {
            Self::get_default_interface()
                .context("No suitable network interface found")?
        };

        println!("{}", format!("[*] Monitoring interface: {}", interface.name).green());
        println!("{}", format!("[*] Duration: {} seconds", self.args.duration).dimmed());

        if self.args.detect_c2 {
            println!("{}", "[*] C2 detection enabled".cyan());
        }
        if self.args.analyze_dns {
            println!("{}", "[*] DNS analysis enabled".cyan());
        }
        if self.args.analyze_http {
            println!("{}", "[*] HTTP analysis enabled".cyan());
        }

        // Create datalink channel
        let (_, mut rx) = match datalink::channel(&interface, Default::default()) {
            Ok(Ethernet(tx, rx)) => (tx, rx),
            Ok(_) => return Err(anyhow::anyhow!("Unhandled channel type")),
            Err(e) => return Err(anyhow::anyhow!("Failed to create channel: {}", e)),
        };

        self.stats.start_time = Local::now().format("%Y-%m-%d %H:%M:%S").to_string();

        let running = Arc::new(AtomicBool::new(true));
        let r = running.clone();

        // Handle Ctrl+C
        ctrlc::set_handler(move || {
            r.store(false, Ordering::SeqCst);
            println!("\n{}", "[*] Stopping capture...".yellow());
        }).context("Failed to set Ctrl+C handler")?;

        let start = Instant::now();
        let duration = if self.args.duration > 0 {
            Duration::from_secs(self.args.duration)
        } else {
            Duration::from_secs(3600 * 24)
        };

        println!("\n{}", "Captured packets:".bold());

        while running.load(Ordering::SeqCst) && start.elapsed() < duration {
            match rx.next() {
                Ok(frame) => {
                    self.process_ethernet_frame(frame);
                }
                Err(e) => {
                    if self.args.verbose {
                        eprintln!("Error receiving frame: {}", e);
                    }
                }
            }

            // Periodically check for beaconing patterns
            if self.args.detect_c2 && self.stats.total_packets % 100 == 0 {
                let beacons = self.beacon_detector.analyze();
                for activity in beacons {
                    println!("\n{}", "!".repeat(50).red());
                    println!("{} {}", "[!]".red().bold(), "C2 Beaconing Detected!".red().bold());
                    println!("  {} -> {}", activity.src_ip, activity.dst_ip);
                    println!("  {}", activity.description.yellow());
                    self.suspicious_activities.push(activity);
                }
            }
        }

        self.stats.end_time = Local::now().format("%Y-%m-%d %H:%M:%S").to_string();

        self.print_summary();
        self.save_results()?;

        Ok(())
    }

    /// Print summary
    fn print_summary(&self) {
        println!("\n{}", "=".repeat(70).cyan());
        println!("{}", "CAPTURE SUMMARY".cyan().bold());
        println!("{}", "=".repeat(70).cyan());

        println!("Start time:        {}", self.stats.start_time);
        println!("End time:          {}", self.stats.end_time);
        println!("Total packets:     {}", self.stats.total_packets);
        println!("Total bytes:       {} KB", self.stats.total_bytes / 1024);
        println!("TCP packets:       {}", self.stats.tcp_packets);
        println!("UDP packets:       {}", self.stats.udp_packets);
        println!("ICMP packets:      {}", self.stats.icmp_packets);
        println!("Unique source IPs: {}", self.stats.unique_src_ips.len());
        println!("Unique dest IPs:   {}", self.stats.unique_dst_ips.len());

        if self.stats.suspicious_packets > 0 {
            println!("{}", format!("\nSuspicious packets: {}",
                self.stats.suspicious_packets).red().bold());
        }

        if !self.suspicious_activities.is_empty() {
            println!("\n{}", "Suspicious Activities Detected:".red().bold());
            for activity in &self.suspicious_activities {
                println!("  [{}] {} - {}",
                    activity.severity.to_uppercase().red(),
                    activity.activity_type,
                    activity.description);
            }
        }

        if !self.stats.port_counts.is_empty() && self.args.verbose {
            println!("\n{}", "Top 10 Destination Ports:".bold());
            let mut sorted: Vec<_> = self.stats.port_counts.iter().collect();
            sorted.sort_by(|a, b| b.1.cmp(a.1));
            for (port, count) in sorted.iter().take(10) {
                let port_name = match **port {
                    22 => "SSH",
                    53 => "DNS",
                    80 => "HTTP",
                    443 => "HTTPS",
                    _ => "",
                };
                println!("  {}: {} packets {}",
                    port, count,
                    if !port_name.is_empty() { format!("({})", port_name) } else { String::new() });
            }
        }
    }

    /// Save results
    fn save_results(&self) -> Result<()> {
        if let Some(ref path) = self.args.output {
            let file = File::create(path)?;
            let mut writer = BufWriter::new(file);

            match self.args.format {
                OutputFormat::Json => {
                    let output = serde_json::json!({
                        "packets": self.packets,
                        "dns_events": self.dns_events,
                        "http_events": self.http_events,
                        "suspicious_activities": self.suspicious_activities,
                        "statistics": {
                            "total_packets": self.stats.total_packets,
                            "total_bytes": self.stats.total_bytes,
                            "suspicious_packets": self.stats.suspicious_packets,
                            "start_time": self.stats.start_time,
                            "end_time": self.stats.end_time
                        }
                    });
                    serde_json::to_writer_pretty(&mut writer, &output)?;
                }
                OutputFormat::Csv => {
                    writeln!(writer, "timestamp,protocol,src_ip,dst_ip,src_port,dst_port,size,suspicious")?;
                    for pkt in &self.packets {
                        writeln!(writer, "{},{},{},{},{:?},{:?},{},{}",
                            pkt.timestamp,
                            pkt.protocol,
                            pkt.src_ip,
                            pkt.dst_ip,
                            pkt.src_port,
                            pkt.dst_port,
                            pkt.payload_size,
                            pkt.suspicious)?;
                    }
                }
                OutputFormat::Text => {
                    for pkt in &self.packets {
                        writeln!(writer, "{} {} {}:{} -> {}:{} ({} bytes){}",
                            pkt.timestamp,
                            pkt.protocol,
                            pkt.src_ip,
                            pkt.src_port.unwrap_or(0),
                            pkt.dst_ip,
                            pkt.dst_port.unwrap_or(0),
                            pkt.payload_size,
                            if pkt.suspicious { " [SUSPICIOUS]" } else { "" })?;
                    }
                }
            }

            println!("{}", format!("\n[*] Results saved to: {}", path).green());
        }
        Ok(())
    }
}

fn main() -> Result<()> {
    let args = Args::parse();
    let mut monitor = NetworkMonitor::new(args);
    monitor.run()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_suspicious_port_detection() {
        let monitor = NetworkMonitor::new(Args::parse_from(["test"]));
        assert!(monitor.is_suspicious_port(4444));
        assert!(monitor.is_suspicious_port(31337));
        assert!(!monitor.is_suspicious_port(80));
        assert!(!monitor.is_suspicious_port(443));
    }

    #[test]
    fn test_suspicious_domain_detection() {
        let monitor = NetworkMonitor::new(Args::parse_from(["test"]));

        let (suspicious, _) = monitor.is_suspicious_domain("evil.com");
        assert!(suspicious);

        let (suspicious, _) = monitor.is_suspicious_domain("google.com");
        assert!(!suspicious);
    }
}
