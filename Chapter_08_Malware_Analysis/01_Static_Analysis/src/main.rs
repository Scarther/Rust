//! Static Binary Analyzer
//!
//! Performs comprehensive static analysis on PE and ELF binaries
//! without executing them.
//!
//! # Usage
//! ```bash
//! static-analyzer --file /path/to/binary -v
//! static-analyzer -f suspicious.exe --output json
//! ```

use clap::Parser;
use goblin::{Object, pe, elf};
use sha2::{Sha256, Digest};
use std::fs;
use std::path::Path;

// ═══════════════════════════════════════════════════════════════════════════
// COMMAND LINE INTERFACE
// ═══════════════════════════════════════════════════════════════════════════

/// Static Binary Analyzer - Extract metadata and indicators from executables
#[derive(Parser, Debug)]
#[command(name = "static-analyzer")]
#[command(about = "Analyze PE/ELF binaries for security indicators")]
struct Args {
    /// Path to the binary file to analyze
    #[arg(short, long)]
    file: String,

    /// Output format (text, json, or csv)
    #[arg(short, long, default_value = "text")]
    output: String,

    /// Enable verbose output
    #[arg(short, long)]
    verbose: bool,

    /// Minimum string length to extract
    #[arg(short, long, default_value = "6")]
    strings: usize,
}

// ═══════════════════════════════════════════════════════════════════════════
// DATA STRUCTURES
// ═══════════════════════════════════════════════════════════════════════════

/// Complete analysis results for a binary
#[derive(Debug)]
struct AnalysisReport {
    file_info: FileInfo,
    pe_info: Option<PeInfo>,
    elf_info: Option<ElfInfo>,
    imports: Vec<ImportInfo>,
    exports: Vec<ExportInfo>,
    strings: Vec<ExtractedString>,
    indicators: Vec<Indicator>,
    risk_score: u32,
}

/// Basic file metadata
#[derive(Debug, Clone)]
struct FileInfo {
    path: String,
    size: u64,
    sha256: String,
    md5: String,
    file_type: FileType,
    entropy: f64,
}

/// Supported file types for analysis
#[derive(Debug, Clone, PartialEq)]
enum FileType {
    PE32,
    PE64,
    ELF32,
    ELF64,
    MachO,
    Unknown,
}

/// Windows PE-specific information
#[derive(Debug, Clone)]
struct PeInfo {
    machine: String,
    num_sections: usize,
    entry_point: u64,
    image_base: u64,
    timestamp: u32,
    subsystem: String,
    sections: Vec<SectionInfo>,
    is_signed: bool,
    characteristics: Vec<String>,
}

/// ELF-specific information
#[derive(Debug, Clone)]
struct ElfInfo {
    machine: String,
    class: String,
    endian: String,
    entry_point: u64,
    sections: Vec<SectionInfo>,
    program_headers: Vec<String>,
    is_dynamic: bool,
    interpreter: Option<String>,
}

/// Binary section information
#[derive(Debug, Clone)]
struct SectionInfo {
    name: String,
    virtual_size: u64,
    raw_size: u64,
    characteristics: Vec<String>,
    entropy: f64,
}

/// Imported function information
#[derive(Debug, Clone)]
struct ImportInfo {
    library: String,
    function: String,
    is_ordinal: bool,
}

/// Exported function information
#[derive(Debug, Clone)]
struct ExportInfo {
    name: String,
    ordinal: u32,
    rva: u64,
}

/// Extracted string with context
#[derive(Debug, Clone)]
struct ExtractedString {
    value: String,
    offset: usize,
    string_type: StringType,
    category: Option<StringCategory>,
}

/// String encoding type
#[derive(Debug, Clone, PartialEq)]
enum StringType {
    Ascii,
    Wide,
}

/// Categorization of interesting strings
#[derive(Debug, Clone, PartialEq)]
enum StringCategory {
    Url,
    IpAddress,
    FilePath,
    RegistryKey,
    Email,
    CryptoWallet,
    Command,
}

/// Security indicator/finding
#[derive(Debug, Clone)]
struct Indicator {
    name: String,
    description: String,
    severity: Severity,
    category: String,
}

/// Severity levels for indicators
#[derive(Debug, Clone, PartialEq, Ord, PartialOrd, Eq)]
enum Severity {
    Low = 1,
    Medium = 2,
    High = 3,
    Critical = 4,
}

// ═══════════════════════════════════════════════════════════════════════════
// IMPLEMENTATION: FileInfo
// ═══════════════════════════════════════════════════════════════════════════

impl FileInfo {
    fn new<P: AsRef<Path>>(path: P) -> Result<Self, String> {
        let path = path.as_ref();

        let data = fs::read(path)
            .map_err(|e| format!("Failed to read file: {}", e))?;

        let metadata = fs::metadata(path)
            .map_err(|e| format!("Failed to get metadata: {}", e))?;

        let sha256 = format!("{:x}", Sha256::digest(&data));
        let md5 = format!("{:x}", md5::compute(&data));

        let file_type = Self::detect_file_type(&data);
        let entropy = Self::calculate_entropy(&data);

        Ok(FileInfo {
            path: path.to_string_lossy().to_string(),
            size: metadata.len(),
            sha256,
            md5,
            file_type,
            entropy,
        })
    }

    fn detect_file_type(data: &[u8]) -> FileType {
        if data.len() < 64 {
            return FileType::Unknown;
        }

        // Check for PE (MZ header)
        if data[0] == 0x4D && data[1] == 0x5A {
            let pe_offset = u32::from_le_bytes([
                data[0x3C], data[0x3D], data[0x3E], data[0x3F]
            ]) as usize;

            if pe_offset + 6 < data.len() {
                if data[pe_offset] == 0x50 && data[pe_offset + 1] == 0x45 {
                    let machine = u16::from_le_bytes([
                        data[pe_offset + 4], data[pe_offset + 5]
                    ]);

                    return match machine {
                        0x014c => FileType::PE32,
                        0x8664 => FileType::PE64,
                        _ => FileType::PE32,
                    };
                }
            }
        }

        // Check for ELF
        if data[0] == 0x7F && &data[1..4] == b"ELF" {
            return match data[4] {
                1 => FileType::ELF32,
                2 => FileType::ELF64,
                _ => FileType::Unknown,
            };
        }

        // Check for Mach-O
        if (data[0] == 0xFE && data[1] == 0xED) ||
           (data[0] == 0xCF && data[1] == 0xFA) {
            return FileType::MachO;
        }

        FileType::Unknown
    }

    fn calculate_entropy(data: &[u8]) -> f64 {
        if data.is_empty() {
            return 0.0;
        }

        let mut freq = [0u64; 256];
        for &byte in data {
            freq[byte as usize] += 1;
        }

        let len = data.len() as f64;
        let mut entropy = 0.0;

        for &count in &freq {
            if count > 0 {
                let p = count as f64 / len;
                entropy -= p * p.log2();
            }
        }

        entropy
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// IMPLEMENTATION: Static Analyzer
// ═══════════════════════════════════════════════════════════════════════════

struct StaticAnalyzer {
    suspicious_imports: Vec<&'static str>,
}

impl StaticAnalyzer {
    fn new() -> Self {
        StaticAnalyzer {
            suspicious_imports: vec![
                // Process manipulation
                "CreateRemoteThread",
                "VirtualAllocEx",
                "WriteProcessMemory",
                "ReadProcessMemory",
                "OpenProcess",
                "NtUnmapViewOfSection",
                // Code injection
                "SetWindowsHookEx",
                "QueueUserAPC",
                "NtQueueApcThread",
                // Privilege escalation
                "AdjustTokenPrivileges",
                "LookupPrivilegeValue",
                // Anti-debugging
                "IsDebuggerPresent",
                "CheckRemoteDebuggerPresent",
                "NtQueryInformationProcess",
                // Persistence
                "RegSetValueEx",
                "CreateService",
                "StartService",
                // Network
                "InternetOpen",
                "HttpSendRequest",
                "WSAStartup",
                // Crypto
                "CryptEncrypt",
                "CryptDecrypt",
            ],
        }
    }

    fn analyze<P: AsRef<Path>>(&self, path: P, min_string_len: usize) -> Result<AnalysisReport, String> {
        let path = path.as_ref();

        let file_info = FileInfo::new(path)?;

        let data = fs::read(path)
            .map_err(|e| format!("Failed to read file: {}", e))?;

        let (pe_info, elf_info, imports, exports) = self.parse_binary(&data)?;
        let strings = self.extract_strings(&data, min_string_len);
        let indicators = self.find_indicators(&file_info, &imports, &strings);
        let risk_score = self.calculate_risk_score(&file_info, &indicators);

        Ok(AnalysisReport {
            file_info,
            pe_info,
            elf_info,
            imports,
            exports,
            strings,
            indicators,
            risk_score,
        })
    }

    fn parse_binary(&self, data: &[u8]) -> Result<(
        Option<PeInfo>,
        Option<ElfInfo>,
        Vec<ImportInfo>,
        Vec<ExportInfo>
    ), String> {
        let mut pe_info = None;
        let mut elf_info = None;
        let mut imports = Vec::new();
        let mut exports = Vec::new();

        match Object::parse(data) {
            Ok(Object::PE(pe)) => {
                pe_info = Some(self.extract_pe_info(&pe));
                imports = self.extract_pe_imports(&pe);
                exports = self.extract_pe_exports(&pe);
            }
            Ok(Object::Elf(elf)) => {
                elf_info = Some(self.extract_elf_info(&elf));
                imports = self.extract_elf_imports(&elf);
                exports = self.extract_elf_exports(&elf);
            }
            Ok(_) => {}
            Err(e) => {
                return Err(format!("Failed to parse binary: {}", e));
            }
        }

        Ok((pe_info, elf_info, imports, exports))
    }

    fn extract_pe_info(&self, pe: &pe::PE) -> PeInfo {
        let header = &pe.header;
        let optional = pe.header.optional_header.as_ref();

        let machine = match header.coff_header.machine {
            0x014c => "i386".to_string(),
            0x8664 => "AMD64".to_string(),
            0x01c4 => "ARM".to_string(),
            0xaa64 => "ARM64".to_string(),
            m => format!("Unknown (0x{:04x})", m),
        };

        let sections: Vec<SectionInfo> = pe.sections.iter().map(|s| {
            let name = String::from_utf8_lossy(&s.name).trim_end_matches('\0').to_string();
            SectionInfo {
                name,
                virtual_size: s.virtual_size as u64,
                raw_size: s.size_of_raw_data as u64,
                characteristics: self.parse_section_characteristics(s.characteristics),
                entropy: 0.0,
            }
        }).collect();

        let subsystem = optional.map(|o| match o.windows_fields.subsystem {
            1 => "Native",
            2 => "GUI",
            3 => "Console",
            _ => "Unknown",
        }).unwrap_or("Unknown").to_string();

        PeInfo {
            machine,
            num_sections: pe.sections.len(),
            entry_point: optional.map(|o| o.standard_fields.address_of_entry_point as u64).unwrap_or(0),
            image_base: optional.map(|o| o.windows_fields.image_base).unwrap_or(0),
            timestamp: header.coff_header.time_date_stamp,
            subsystem,
            sections,
            is_signed: false,
            characteristics: self.parse_pe_characteristics(header.coff_header.characteristics),
        }
    }

    fn parse_section_characteristics(&self, chars: u32) -> Vec<String> {
        let mut result = Vec::new();
        if chars & 0x20 != 0 { result.push("CODE".to_string()); }
        if chars & 0x40 != 0 { result.push("INITIALIZED_DATA".to_string()); }
        if chars & 0x80 != 0 { result.push("UNINITIALIZED_DATA".to_string()); }
        if chars & 0x20000000 != 0 { result.push("EXECUTE".to_string()); }
        if chars & 0x40000000 != 0 { result.push("READ".to_string()); }
        if chars & 0x80000000 != 0 { result.push("WRITE".to_string()); }
        result
    }

    fn parse_pe_characteristics(&self, chars: u16) -> Vec<String> {
        let mut result = Vec::new();
        if chars & 0x0002 != 0 { result.push("EXECUTABLE".to_string()); }
        if chars & 0x0020 != 0 { result.push("LARGE_ADDRESS_AWARE".to_string()); }
        if chars & 0x0100 != 0 { result.push("32BIT".to_string()); }
        if chars & 0x2000 != 0 { result.push("DLL".to_string()); }
        result
    }

    fn extract_pe_imports(&self, pe: &pe::PE) -> Vec<ImportInfo> {
        pe.imports.iter().map(|import| {
            ImportInfo {
                library: import.dll.to_string(),
                function: import.name.to_string(),
                is_ordinal: import.ordinal != 0,
            }
        }).collect()
    }

    fn extract_pe_exports(&self, pe: &pe::PE) -> Vec<ExportInfo> {
        pe.exports.iter().filter_map(|export| {
            export.name.map(|name| {
                ExportInfo {
                    name: name.to_string(),
                    ordinal: export.ordinal.unwrap_or(0) as u32,
                    rva: export.rva as u64,
                }
            })
        }).collect()
    }

    fn extract_elf_info(&self, elf: &elf::Elf) -> ElfInfo {
        let machine = match elf.header.e_machine {
            0x03 => "i386".to_string(),
            0x3E => "x86_64".to_string(),
            0x28 => "ARM".to_string(),
            0xB7 => "ARM64".to_string(),
            m => format!("Unknown (0x{:04x})", m),
        };

        let class = if elf.is_64 { "ELF64" } else { "ELF32" }.to_string();
        let endian = if elf.little_endian { "Little" } else { "Big" }.to_string();

        let sections: Vec<SectionInfo> = elf.section_headers.iter().map(|s| {
            let name = elf.shdr_strtab.get_at(s.sh_name).unwrap_or("").to_string();
            SectionInfo {
                name,
                virtual_size: s.sh_size,
                raw_size: s.sh_size,
                characteristics: vec![],
                entropy: 0.0,
            }
        }).collect();

        let interpreter = elf.interpreter.map(|i| i.to_string());

        ElfInfo {
            machine,
            class,
            endian,
            entry_point: elf.entry,
            sections,
            program_headers: vec![],
            is_dynamic: elf.is_lib,
            interpreter,
        }
    }

    fn extract_elf_imports(&self, elf: &elf::Elf) -> Vec<ImportInfo> {
        elf.dynsyms.iter().filter_map(|sym| {
            if sym.is_import() {
                elf.dynstrtab.get_at(sym.st_name).map(|name| {
                    ImportInfo {
                        library: "libc.so.6".to_string(),
                        function: name.to_string(),
                        is_ordinal: false,
                    }
                })
            } else {
                None
            }
        }).collect()
    }

    fn extract_elf_exports(&self, elf: &elf::Elf) -> Vec<ExportInfo> {
        elf.dynsyms.iter().enumerate().filter_map(|(i, sym)| {
            if !sym.is_import() && sym.st_value != 0 {
                elf.dynstrtab.get_at(sym.st_name).map(|name| {
                    ExportInfo {
                        name: name.to_string(),
                        ordinal: i as u32,
                        rva: sym.st_value,
                    }
                })
            } else {
                None
            }
        }).collect()
    }

    fn extract_strings(&self, data: &[u8], min_length: usize) -> Vec<ExtractedString> {
        let mut strings = Vec::new();
        let mut current = String::new();
        let mut start_offset = 0;

        for (i, &byte) in data.iter().enumerate() {
            if byte >= 0x20 && byte < 0x7F {
                if current.is_empty() {
                    start_offset = i;
                }
                current.push(byte as char);
            } else if current.len() >= min_length {
                let category = self.categorize_string(&current);
                strings.push(ExtractedString {
                    value: current.clone(),
                    offset: start_offset,
                    string_type: StringType::Ascii,
                    category,
                });
                current.clear();
            } else {
                current.clear();
            }
        }

        if current.len() >= min_length {
            let category = self.categorize_string(&current);
            strings.push(ExtractedString {
                value: current,
                offset: start_offset,
                string_type: StringType::Ascii,
                category,
            });
        }

        strings
    }

    fn categorize_string(&self, s: &str) -> Option<StringCategory> {
        if s.starts_with("http://") || s.starts_with("https://") {
            return Some(StringCategory::Url);
        }

        if s.chars().all(|c| c.is_ascii_digit() || c == '.') {
            let parts: Vec<&str> = s.split('.').collect();
            if parts.len() == 4 && parts.iter().all(|p| p.parse::<u8>().is_ok()) {
                return Some(StringCategory::IpAddress);
            }
        }

        if s.starts_with("HKEY_") || s.contains("\\Software\\") {
            return Some(StringCategory::RegistryKey);
        }

        if s.contains(":\\") || s.starts_with("/") {
            return Some(StringCategory::FilePath);
        }

        if s.contains("cmd.exe") || s.contains("powershell") {
            return Some(StringCategory::Command);
        }

        None
    }

    fn find_indicators(
        &self,
        file_info: &FileInfo,
        imports: &[ImportInfo],
        strings: &[ExtractedString],
    ) -> Vec<Indicator> {
        let mut indicators = Vec::new();

        if file_info.entropy > 7.0 {
            indicators.push(Indicator {
                name: "HIGH_ENTROPY".to_string(),
                description: format!(
                    "File has high entropy ({:.2}), indicating possible packing or encryption",
                    file_info.entropy
                ),
                severity: Severity::Medium,
                category: "packing".to_string(),
            });
        }

        for import in imports {
            if self.suspicious_imports.contains(&import.function.as_str()) {
                indicators.push(Indicator {
                    name: format!("SUSPICIOUS_IMPORT_{}", import.function.to_uppercase()),
                    description: format!(
                        "Imports suspicious function: {} from {}",
                        import.function, import.library
                    ),
                    severity: Severity::Medium,
                    category: "imports".to_string(),
                });
            }
        }

        for s in strings {
            if s.category == Some(StringCategory::IpAddress) {
                indicators.push(Indicator {
                    name: "EMBEDDED_IP".to_string(),
                    description: format!("Contains embedded IP address: {}", s.value),
                    severity: Severity::Low,
                    category: "network".to_string(),
                });
            }

            if s.category == Some(StringCategory::Command) {
                indicators.push(Indicator {
                    name: "COMMAND_EXECUTION".to_string(),
                    description: format!("References command interpreter: {}", s.value),
                    severity: Severity::Medium,
                    category: "execution".to_string(),
                });
            }
        }

        indicators
    }

    fn calculate_risk_score(&self, file_info: &FileInfo, indicators: &[Indicator]) -> u32 {
        let mut score = 0u32;

        if file_info.entropy > 7.5 {
            score += 20;
        } else if file_info.entropy > 7.0 {
            score += 10;
        }

        for indicator in indicators {
            score += match indicator.severity {
                Severity::Low => 5,
                Severity::Medium => 15,
                Severity::High => 30,
                Severity::Critical => 50,
            };
        }

        score.min(100)
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// MAIN FUNCTION
// ═══════════════════════════════════════════════════════════════════════════

fn main() {
    let args = Args::parse();

    println!("╔════════════════════════════════════════════════════════════════╗");
    println!("║             STATIC BINARY ANALYZER                              ║");
    println!("╚════════════════════════════════════════════════════════════════╝\n");

    let analyzer = StaticAnalyzer::new();

    match analyzer.analyze(&args.file, args.strings) {
        Ok(report) => {
            // File Info
            println!("[*] File Information");
            println!("    Path:    {}", report.file_info.path);
            println!("    Size:    {} bytes", report.file_info.size);
            println!("    SHA256:  {}", report.file_info.sha256);
            println!("    MD5:     {}", report.file_info.md5);
            println!("    Type:    {:?}", report.file_info.file_type);
            println!("    Entropy: {:.4}", report.file_info.entropy);

            // PE Info
            if let Some(pe) = &report.pe_info {
                println!("\n[*] PE Information");
                println!("    Machine:      {}", pe.machine);
                println!("    Sections:     {}", pe.num_sections);
                println!("    Entry Point:  0x{:X}", pe.entry_point);
                println!("    Image Base:   0x{:X}", pe.image_base);
                println!("    Subsystem:    {}", pe.subsystem);
                println!("    Timestamp:    {}", pe.timestamp);

                if args.verbose {
                    println!("\n    Sections:");
                    for section in &pe.sections {
                        println!("      {} (V:{} R:{}) {:?}",
                            section.name,
                            section.virtual_size,
                            section.raw_size,
                            section.characteristics
                        );
                    }
                }
            }

            // ELF Info
            if let Some(elf) = &report.elf_info {
                println!("\n[*] ELF Information");
                println!("    Machine:     {}", elf.machine);
                println!("    Class:       {}", elf.class);
                println!("    Endian:      {}", elf.endian);
                println!("    Entry Point: 0x{:X}", elf.entry_point);
                println!("    Dynamic:     {}", elf.is_dynamic);
                if let Some(interp) = &elf.interpreter {
                    println!("    Interpreter: {}", interp);
                }
            }

            // Imports
            println!("\n[*] Imports: {} total", report.imports.len());
            if args.verbose && !report.imports.is_empty() {
                for import in report.imports.iter().take(20) {
                    println!("    {} -> {}", import.library, import.function);
                }
                if report.imports.len() > 20 {
                    println!("    ... and {} more", report.imports.len() - 20);
                }
            }

            // Exports
            if !report.exports.is_empty() {
                println!("\n[*] Exports: {} total", report.exports.len());
            }

            // Interesting Strings
            let interesting: Vec<_> = report.strings.iter()
                .filter(|s| s.category.is_some())
                .collect();
            if !interesting.is_empty() {
                println!("\n[*] Interesting Strings:");
                for s in interesting.iter().take(10) {
                    println!("    [{:?}] {}", s.category.as_ref().unwrap(), s.value);
                }
            }

            // Indicators
            if !report.indicators.is_empty() {
                println!("\n[!] Security Indicators:");
                for ind in &report.indicators {
                    let severity_str = match ind.severity {
                        Severity::Low => "LOW",
                        Severity::Medium => "MEDIUM",
                        Severity::High => "HIGH",
                        Severity::Critical => "CRITICAL",
                    };
                    println!("    [{}] {}: {}", severity_str, ind.name, ind.description);
                }
            }

            // Risk Score
            println!("\n[*] Risk Score: {}/100", report.risk_score);
            let verdict = match report.risk_score {
                0..=20 => "CLEAN",
                21..=50 => "SUSPICIOUS",
                51..=80 => "LIKELY MALICIOUS",
                _ => "MALICIOUS",
            };
            println!("[*] Verdict: {}", verdict);
        }
        Err(e) => {
            eprintln!("[-] Analysis failed: {}", e);
            std::process::exit(1);
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_entropy_calculation() {
        let uniform = vec![0u8; 1000];
        assert!(FileInfo::calculate_entropy(&uniform) < 0.001);

        let random: Vec<u8> = (0..=255).cycle().take(1000).collect();
        assert!(FileInfo::calculate_entropy(&random) > 7.0);
    }

    #[test]
    fn test_file_type_detection() {
        let mut elf_data = vec![0x7F, 0x45, 0x4C, 0x46, 0x02];
        elf_data.resize(64, 0);
        assert_eq!(FileInfo::detect_file_type(&elf_data), FileType::ELF64);
    }

    #[test]
    fn test_string_extraction() {
        let analyzer = StaticAnalyzer::new();
        let data = b"Hello, this is a test string\x00\x00garbage\x00http://example.com";
        let strings = analyzer.extract_strings(data, 4);

        assert!(strings.iter().any(|s| s.value.contains("Hello")));
        assert!(strings.iter().any(|s| s.category == Some(StringCategory::Url)));
    }
}
