# MA01: Static Binary Analysis

## Overview

| Property | Value |
|----------|-------|
| **ID** | MA01 |
| **Difficulty** | Advanced |
| **Skills** | Binary parsing, PE/ELF formats, pattern matching |
| **Prerequisites** | B01-B15, I01-I10 |
| **Crates** | goblin, sha2, regex, clap |

## What You'll Learn

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         STATIC ANALYSIS CONCEPTS                             │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐       │
│  │  FILE HEADERS   │     │    SECTIONS     │     │    IMPORTS      │       │
│  │  ───────────    │     │  ───────────    │     │  ───────────    │       │
│  │  • DOS Header   │     │  • .text        │     │  • DLL names    │       │
│  │  • PE Header    │     │  • .data        │     │  • API calls    │       │
│  │  • Optional Hdr │     │  • .rdata       │     │  • Ordinals     │       │
│  │  • Magic bytes  │     │  • Entropy      │     │  • Thunks       │       │
│  └─────────────────┘     └─────────────────┘     └─────────────────┘       │
│                                                                              │
│  ┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐       │
│  │    STRINGS      │     │    EXPORTS      │     │   RESOURCES     │       │
│  │  ───────────    │     │  ───────────    │     │  ───────────    │       │
│  │  • ASCII/Wide   │     │  • Functions    │     │  • Icons        │       │
│  │  • URLs/IPs     │     │  • Variables    │     │  • Manifests    │       │
│  │  • Paths        │     │  • Forwarders   │     │  • Version      │       │
│  │  • Registry     │     │  • RVAs         │     │  • Embedded     │       │
│  └─────────────────┘     └─────────────────┘     └─────────────────┘       │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

## The Code

```rust
//! Static Binary Analyzer
//!
//! Performs comprehensive static analysis on PE and ELF binaries
//! without executing them.

use clap::Parser;
use goblin::{Object, pe, elf};
use sha2::{Sha256, Digest};
use std::fs;
use std::path::Path;
use std::collections::HashMap;

// ═══════════════════════════════════════════════════════════════════════════
// COMMAND LINE INTERFACE
// ═══════════════════════════════════════════════════════════════════════════

/// Static Binary Analyzer - Extract metadata and indicators from executables
///
/// # Struct Breakdown
/// This struct uses clap's derive macro to automatically generate a CLI parser.
/// Each field becomes a command-line argument.
#[derive(Parser, Debug)]
#[command(name = "static-analyzer")]
#[command(about = "Analyze PE/ELF binaries for security indicators")]
struct Args {
    /// Path to the binary file to analyze
    ///
    /// # Field Explanation
    /// - Type: String (owned, not a reference)
    /// - Required: Yes (no default value)
    /// - The #[arg] attribute configures clap
    #[arg(short, long)]
    file: String,

    /// Output format (text, json, or csv)
    ///
    /// # Default Value
    /// Uses the `default_value` attribute for optional args
    #[arg(short, long, default_value = "text")]
    output: String,

    /// Enable verbose output
    ///
    /// # Boolean Flags
    /// For boolean flags, we use `action = ArgAction::SetTrue`
    /// Alternatively, just include the arg and it defaults to false
    #[arg(short, long)]
    verbose: bool,

    /// Extract all strings (minimum length)
    ///
    /// # Optional Values
    /// Option<T> makes the argument optional with no default
    #[arg(short, long)]
    strings: Option<usize>,
}

// ═══════════════════════════════════════════════════════════════════════════
// DATA STRUCTURES
// ═══════════════════════════════════════════════════════════════════════════

/// Complete analysis results for a binary
///
/// # Struct Design Philosophy
/// This struct uses composition - it contains other structs for different
/// aspects of the analysis. This promotes:
/// - Single Responsibility: Each sub-struct handles one concern
/// - Reusability: Sub-structs can be used independently
/// - Testability: Easy to test individual components
#[derive(Debug)]
struct AnalysisReport {
    /// Basic file information (always present)
    file_info: FileInfo,

    /// PE-specific information (only for Windows executables)
    ///
    /// # Why Option<T>?
    /// Not all files are PE files. Option lets us represent "no data"
    /// without using null pointers or sentinel values.
    pe_info: Option<PeInfo>,

    /// ELF-specific information (only for Linux executables)
    elf_info: Option<ElfInfo>,

    /// Imported functions and libraries
    imports: Vec<ImportInfo>,

    /// Exported functions
    exports: Vec<ExportInfo>,

    /// Extracted strings
    strings: Vec<ExtractedString>,

    /// Security indicators and suspicious patterns
    indicators: Vec<Indicator>,

    /// Overall risk score (0-100)
    risk_score: u32,
}

/// Basic file metadata
///
/// # Fields Explained
/// Each field captures essential information about the file:
#[derive(Debug, Clone)]
struct FileInfo {
    /// Original file path
    path: String,

    /// File size in bytes
    ///
    /// # Type Choice: u64
    /// - u64 can hold values up to 18 exabytes
    /// - Matches what std::fs::metadata returns
    /// - unsigned because file sizes can't be negative
    size: u64,

    /// SHA256 hash (64 hex characters)
    sha256: String,

    /// MD5 hash (32 hex characters)
    ///
    /// # Why Both Hashes?
    /// - SHA256: More secure, used for modern IOC databases
    /// - MD5: Still used by some legacy systems and VirusTotal
    md5: String,

    /// Detected file type
    file_type: FileType,

    /// Entropy value (0.0 - 8.0)
    ///
    /// # What is Entropy?
    /// Entropy measures randomness. High entropy (>7.0) often indicates:
    /// - Packed/compressed executables
    /// - Encrypted payloads
    /// - Obfuscated malware
    entropy: f64,
}

/// Supported file types for analysis
///
/// # Enum Design
/// Using an enum instead of strings provides:
/// - Compile-time checking (can't misspell a variant)
/// - Exhaustive matching (compiler warns if you miss a case)
/// - Pattern matching support
#[derive(Debug, Clone, PartialEq)]
enum FileType {
    /// Windows Portable Executable
    PE32,
    /// Windows 64-bit Portable Executable
    PE64,
    /// Linux 32-bit ELF
    ELF32,
    /// Linux 64-bit ELF
    ELF64,
    /// macOS Mach Object
    MachO,
    /// Unknown or unsupported format
    Unknown,
}

/// Windows PE-specific information
///
/// # PE File Format Overview
/// ```
/// ┌──────────────────┐
/// │    DOS Header    │  <- Legacy header (MZ signature)
/// ├──────────────────┤
/// │    DOS Stub      │  <- "This program cannot be run in DOS mode"
/// ├──────────────────┤
/// │   PE Signature   │  <- "PE\0\0"
/// ├──────────────────┤
/// │   File Header    │  <- Machine type, number of sections
/// ├──────────────────┤
/// │  Optional Header │  <- Entry point, image base, subsystem
/// ├──────────────────┤
/// │ Section Headers  │  <- .text, .data, .rdata, etc.
/// ├──────────────────┤
/// │     Sections     │  <- Actual code and data
/// └──────────────────┘
/// ```
#[derive(Debug, Clone)]
struct PeInfo {
    /// Machine architecture (e.g., AMD64, i386)
    machine: String,

    /// Number of sections in the PE
    num_sections: usize,

    /// Entry point address (RVA)
    ///
    /// # What is RVA?
    /// Relative Virtual Address - offset from the image base
    /// where execution begins.
    entry_point: u64,

    /// Image base address
    image_base: u64,

    /// Compilation timestamp (Unix epoch)
    ///
    /// # Security Note
    /// Malware authors often fake this timestamp
    timestamp: u32,

    /// Subsystem (Console, GUI, Driver, etc.)
    subsystem: String,

    /// Section information
    sections: Vec<SectionInfo>,

    /// Is the file digitally signed?
    is_signed: bool,

    /// DLL characteristics flags
    characteristics: Vec<String>,
}

/// ELF-specific information
#[derive(Debug, Clone)]
struct ElfInfo {
    /// Target machine architecture
    machine: String,

    /// ELF class (32-bit or 64-bit)
    class: String,

    /// Endianness (little or big)
    endian: String,

    /// Entry point address
    entry_point: u64,

    /// Section information
    sections: Vec<SectionInfo>,

    /// Program headers
    program_headers: Vec<String>,

    /// Dynamic linking information
    is_dynamic: bool,

    /// Interpreter path (e.g., /lib64/ld-linux-x86-64.so.2)
    interpreter: Option<String>,
}

/// Binary section information
///
/// # Why Sections Matter
/// Sections reveal what the binary contains:
/// - .text: Executable code
/// - .data: Initialized data
/// - .bss: Uninitialized data
/// - .rdata/.rodata: Read-only data
/// - .rsrc: Resources (icons, manifests)
///
/// Unusual sections or high entropy can indicate packing/encryption.
#[derive(Debug, Clone)]
struct SectionInfo {
    /// Section name (e.g., ".text", ".data")
    name: String,

    /// Virtual size (size in memory)
    virtual_size: u64,

    /// Raw size (size on disk)
    raw_size: u64,

    /// Section characteristics/flags
    characteristics: Vec<String>,

    /// Section entropy
    entropy: f64,
}

/// Imported function information
///
/// # Why Imports Are Important
/// Imports reveal what APIs the program uses:
/// - CreateRemoteThread: Often used for code injection
/// - VirtualAllocEx: Remote memory allocation
/// - RegSetValueEx: Registry modification
/// - InternetOpen: Network communication
#[derive(Debug, Clone)]
struct ImportInfo {
    /// Library name (DLL for PE, shared object for ELF)
    library: String,

    /// Function name
    function: String,

    /// Is this import by ordinal (number) instead of name?
    ///
    /// # Ordinal Imports
    /// Some malware imports by ordinal to evade string-based detection
    is_ordinal: bool,
}

/// Exported function information
#[derive(Debug, Clone)]
struct ExportInfo {
    /// Function name
    name: String,

    /// Ordinal number
    ordinal: u32,

    /// Relative virtual address
    rva: u64,
}

/// Extracted string with context
#[derive(Debug, Clone)]
struct ExtractedString {
    /// The string content
    value: String,

    /// Offset in the file
    offset: usize,

    /// String type (ASCII or Wide/Unicode)
    string_type: StringType,

    /// Category (URL, IP, path, registry, etc.)
    category: Option<StringCategory>,
}

/// String encoding type
#[derive(Debug, Clone, PartialEq)]
enum StringType {
    Ascii,
    Wide,  // UTF-16LE (common in Windows)
}

/// Categorization of interesting strings
#[derive(Debug, Clone, PartialEq)]
enum StringCategory {
    Url,
    IpAddress,
    FilePath,
    RegistryKey,
    Email,
    CryptoWallet,
    Command,
}

/// Security indicator/finding
///
/// # Indicator Severity Levels
/// - High: Strong indicator of malicious behavior
/// - Medium: Suspicious but could be legitimate
/// - Low: Worth noting but often benign
#[derive(Debug, Clone)]
struct Indicator {
    /// Short identifier
    name: String,

    /// Detailed description
    description: String,

    /// Severity level
    severity: Severity,

    /// Category of indicator
    category: String,
}

/// Severity levels for indicators
#[derive(Debug, Clone, PartialEq, Ord, PartialOrd, Eq)]
enum Severity {
    Low = 1,
    Medium = 2,
    High = 3,
    Critical = 4,
}

// ═══════════════════════════════════════════════════════════════════════════
// IMPLEMENTATION: FileInfo
// ═══════════════════════════════════════════════════════════════════════════

impl FileInfo {
    /// Creates FileInfo from a file path
    ///
    /// # Method Signature Breakdown
    ///
    /// ```text
    /// fn new<P: AsRef<Path>>(path: P) -> Result<Self, String>
    ///    │   │              │       │              │
    ///    │   │              │       │              └── Error type (String for simplicity)
    ///    │   │              │       └── Return type (Result for error handling)
    ///    │   │              └── Parameter (any type that can reference a Path)
    ///    │   └── Generic type bound (trait constraint)
    ///    └── Function name
    /// ```
    ///
    /// # Generic Bounds Explained
    /// `<P: AsRef<Path>>` means:
    /// - P is a generic type parameter
    /// - P must implement the AsRef<Path> trait
    /// - This allows passing: &str, String, PathBuf, &Path
    fn new<P: AsRef<Path>>(path: P) -> Result<Self, String> {
        let path = path.as_ref();

        // Read file contents
        let data = fs::read(path)
            .map_err(|e| format!("Failed to read file: {}", e))?;

        // Get file metadata
        let metadata = fs::metadata(path)
            .map_err(|e| format!("Failed to get metadata: {}", e))?;

        // Calculate hashes
        let sha256 = format!("{:x}", Sha256::digest(&data));
        let md5 = format!("{:x}", md5::compute(&data));

        // Detect file type
        let file_type = Self::detect_file_type(&data);

        // Calculate entropy
        let entropy = Self::calculate_entropy(&data);

        Ok(FileInfo {
            path: path.to_string_lossy().to_string(),
            size: metadata.len(),
            sha256,
            md5,
            file_type,
            entropy,
        })
    }

    /// Detects file type from magic bytes
    ///
    /// # Magic Bytes Reference
    /// | File Type | Magic Bytes | Hex |
    /// |-----------|-------------|-----|
    /// | PE (DOS)  | MZ          | 4D 5A |
    /// | ELF       | .ELF        | 7F 45 4C 46 |
    /// | Mach-O    | Various     | FE ED FA CE/CF |
    fn detect_file_type(data: &[u8]) -> FileType {
        if data.len() < 64 {
            return FileType::Unknown;
        }

        // Check for PE
        if data[0] == 0x4D && data[1] == 0x5A {
            // Find PE header offset at 0x3C
            let pe_offset = u32::from_le_bytes([
                data[0x3C], data[0x3D], data[0x3E], data[0x3F]
            ]) as usize;

            if pe_offset + 6 < data.len() {
                // Check for PE signature
                if data[pe_offset] == 0x50 && data[pe_offset + 1] == 0x45 {
                    // Check machine type at PE + 4
                    let machine = u16::from_le_bytes([
                        data[pe_offset + 4], data[pe_offset + 5]
                    ]);

                    return match machine {
                        0x014c => FileType::PE32,  // i386
                        0x8664 => FileType::PE64,  // AMD64
                        _ => FileType::PE32,
                    };
                }
            }
        }

        // Check for ELF
        if data[0] == 0x7F && &data[1..4] == b"ELF" {
            return match data[4] {
                1 => FileType::ELF32,
                2 => FileType::ELF64,
                _ => FileType::Unknown,
            };
        }

        // Check for Mach-O
        if (data[0] == 0xFE && data[1] == 0xED) ||
           (data[0] == 0xCF && data[1] == 0xFA) {
            return FileType::MachO;
        }

        FileType::Unknown
    }

    /// Calculates Shannon entropy of data
    ///
    /// # Entropy Explained
    ///
    /// Shannon entropy measures the randomness of data:
    /// - 0.0: Completely uniform (all same byte)
    /// - 8.0: Maximum randomness (all bytes equally likely)
    ///
    /// Typical values:
    /// - Plain text: 4.0-5.0
    /// - Normal executables: 5.5-6.5
    /// - Packed/encrypted: 7.0-8.0
    ///
    /// # Algorithm
    /// H = -Σ p(x) * log2(p(x))
    /// where p(x) is the probability of byte value x
    fn calculate_entropy(data: &[u8]) -> f64 {
        if data.is_empty() {
            return 0.0;
        }

        // Count byte frequencies
        let mut freq = [0u64; 256];
        for &byte in data {
            freq[byte as usize] += 1;
        }

        let len = data.len() as f64;
        let mut entropy = 0.0;

        // Calculate entropy
        for &count in &freq {
            if count > 0 {
                let p = count as f64 / len;
                entropy -= p * p.log2();
            }
        }

        entropy
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// IMPLEMENTATION: Static Analyzer
// ═══════════════════════════════════════════════════════════════════════════

/// The main static analyzer
///
/// # Struct Purpose
/// Coordinates all analysis operations and maintains state like
/// suspicious patterns to check for.
struct StaticAnalyzer {
    /// Suspicious import names to flag
    suspicious_imports: Vec<&'static str>,

    /// Suspicious string patterns (regex)
    suspicious_patterns: Vec<(String, StringCategory)>,
}

impl StaticAnalyzer {
    /// Creates a new analyzer with default detection rules
    fn new() -> Self {
        StaticAnalyzer {
            suspicious_imports: vec![
                // Process manipulation
                "CreateRemoteThread",
                "VirtualAllocEx",
                "WriteProcessMemory",
                "ReadProcessMemory",
                "OpenProcess",
                "NtUnmapViewOfSection",
                // Code injection
                "SetWindowsHookEx",
                "QueueUserAPC",
                "NtQueueApcThread",
                // Privilege escalation
                "AdjustTokenPrivileges",
                "LookupPrivilegeValue",
                // Anti-debugging
                "IsDebuggerPresent",
                "CheckRemoteDebuggerPresent",
                "NtQueryInformationProcess",
                // Persistence
                "RegSetValueEx",
                "CreateService",
                "StartService",
                // Network
                "InternetOpen",
                "HttpSendRequest",
                "WSAStartup",
                // Crypto
                "CryptEncrypt",
                "CryptDecrypt",
                "CryptAcquireContext",
            ],
            suspicious_patterns: vec![
                (r"https?://\d+\.\d+\.\d+\.\d+".to_string(), StringCategory::Url),
                (r"\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}".to_string(), StringCategory::IpAddress),
                (r"HKEY_(LOCAL_MACHINE|CURRENT_USER)\\".to_string(), StringCategory::RegistryKey),
                (r"cmd\.exe|powershell\.exe".to_string(), StringCategory::Command),
            ],
        }
    }

    /// Performs complete analysis on a binary
    ///
    /// # Analysis Steps
    /// 1. Extract basic file info (size, hashes, type)
    /// 2. Parse binary format (PE or ELF)
    /// 3. Extract imports and exports
    /// 4. Scan for strings
    /// 5. Identify suspicious indicators
    /// 6. Calculate risk score
    fn analyze<P: AsRef<Path>>(&self, path: P) -> Result<AnalysisReport, String> {
        let path = path.as_ref();

        // Step 1: Basic file info
        let file_info = FileInfo::new(path)?;

        // Read file for parsing
        let data = fs::read(path)
            .map_err(|e| format!("Failed to read file: {}", e))?;

        // Step 2 & 3: Parse binary format
        let (pe_info, elf_info, imports, exports) = self.parse_binary(&data)?;

        // Step 4: Extract strings
        let strings = self.extract_strings(&data, 6);

        // Step 5: Identify indicators
        let indicators = self.find_indicators(&file_info, &imports, &strings);

        // Step 6: Calculate risk score
        let risk_score = self.calculate_risk_score(&file_info, &indicators);

        Ok(AnalysisReport {
            file_info,
            pe_info,
            elf_info,
            imports,
            exports,
            strings,
            indicators,
            risk_score,
        })
    }

    /// Parses the binary using goblin
    ///
    /// # Why goblin?
    /// goblin is a cross-platform binary parsing library that handles:
    /// - PE (Windows)
    /// - ELF (Linux)
    /// - Mach-O (macOS)
    /// - Archives
    ///
    /// It's fast, safe, and well-maintained.
    fn parse_binary(&self, data: &[u8]) -> Result<(
        Option<PeInfo>,
        Option<ElfInfo>,
        Vec<ImportInfo>,
        Vec<ExportInfo>
    ), String> {
        let mut pe_info = None;
        let mut elf_info = None;
        let mut imports = Vec::new();
        let mut exports = Vec::new();

        // Parse with goblin
        match Object::parse(data) {
            Ok(Object::PE(pe)) => {
                // Extract PE information
                pe_info = Some(self.extract_pe_info(&pe));
                imports = self.extract_pe_imports(&pe);
                exports = self.extract_pe_exports(&pe);
            }
            Ok(Object::Elf(elf)) => {
                // Extract ELF information
                elf_info = Some(self.extract_elf_info(&elf));
                imports = self.extract_elf_imports(&elf);
                exports = self.extract_elf_exports(&elf);
            }
            Ok(_) => {
                // Mach-O or archive - simplified handling
            }
            Err(e) => {
                return Err(format!("Failed to parse binary: {}", e));
            }
        }

        Ok((pe_info, elf_info, imports, exports))
    }

    /// Extracts PE-specific information
    fn extract_pe_info(&self, pe: &pe::PE) -> PeInfo {
        let header = &pe.header;
        let optional = pe.header.optional_header.as_ref();

        // Extract machine type
        let machine = match header.coff_header.machine {
            0x014c => "i386".to_string(),
            0x8664 => "AMD64".to_string(),
            0x01c4 => "ARM".to_string(),
            0xaa64 => "ARM64".to_string(),
            m => format!("Unknown (0x{:04x})", m),
        };

        // Extract section info
        let sections: Vec<SectionInfo> = pe.sections.iter().map(|s| {
            let name = String::from_utf8_lossy(&s.name).trim_end_matches('\0').to_string();
            SectionInfo {
                name,
                virtual_size: s.virtual_size as u64,
                raw_size: s.size_of_raw_data as u64,
                characteristics: self.parse_section_characteristics(s.characteristics),
                entropy: 0.0, // Would calculate per-section
            }
        }).collect();

        // Extract subsystem
        let subsystem = optional.map(|o| match o.windows_fields.subsystem {
            1 => "Native",
            2 => "GUI",
            3 => "Console",
            _ => "Unknown",
        }).unwrap_or("Unknown").to_string();

        PeInfo {
            machine,
            num_sections: pe.sections.len(),
            entry_point: optional.map(|o| o.standard_fields.address_of_entry_point as u64).unwrap_or(0),
            image_base: optional.map(|o| o.windows_fields.image_base).unwrap_or(0),
            timestamp: header.coff_header.time_date_stamp,
            subsystem,
            sections,
            is_signed: false, // Would need to check certificate table
            characteristics: self.parse_pe_characteristics(header.coff_header.characteristics),
        }
    }

    /// Parses PE section characteristics flags
    fn parse_section_characteristics(&self, chars: u32) -> Vec<String> {
        let mut result = Vec::new();

        if chars & 0x20 != 0 { result.push("CODE".to_string()); }
        if chars & 0x40 != 0 { result.push("INITIALIZED_DATA".to_string()); }
        if chars & 0x80 != 0 { result.push("UNINITIALIZED_DATA".to_string()); }
        if chars & 0x20000000 != 0 { result.push("EXECUTE".to_string()); }
        if chars & 0x40000000 != 0 { result.push("READ".to_string()); }
        if chars & 0x80000000 != 0 { result.push("WRITE".to_string()); }

        result
    }

    /// Parses PE file characteristics flags
    fn parse_pe_characteristics(&self, chars: u16) -> Vec<String> {
        let mut result = Vec::new();

        if chars & 0x0002 != 0 { result.push("EXECUTABLE".to_string()); }
        if chars & 0x0020 != 0 { result.push("LARGE_ADDRESS_AWARE".to_string()); }
        if chars & 0x0100 != 0 { result.push("32BIT".to_string()); }
        if chars & 0x2000 != 0 { result.push("DLL".to_string()); }

        result
    }

    /// Extracts imports from PE file
    fn extract_pe_imports(&self, pe: &pe::PE) -> Vec<ImportInfo> {
        let mut imports = Vec::new();

        for import in &pe.imports {
            imports.push(ImportInfo {
                library: import.dll.to_string(),
                function: import.name.to_string(),
                is_ordinal: import.ordinal != 0,
            });
        }

        imports
    }

    /// Extracts exports from PE file
    fn extract_pe_exports(&self, pe: &pe::PE) -> Vec<ExportInfo> {
        let mut exports = Vec::new();

        for export in &pe.exports {
            if let Some(name) = export.name {
                exports.push(ExportInfo {
                    name: name.to_string(),
                    ordinal: export.ordinal.unwrap_or(0) as u32,
                    rva: export.rva as u64,
                });
            }
        }

        exports
    }

    /// Extracts ELF-specific information
    fn extract_elf_info(&self, elf: &elf::Elf) -> ElfInfo {
        let machine = match elf.header.e_machine {
            0x03 => "i386".to_string(),
            0x3E => "x86_64".to_string(),
            0x28 => "ARM".to_string(),
            0xB7 => "ARM64".to_string(),
            m => format!("Unknown (0x{:04x})", m),
        };

        let class = if elf.is_64 { "ELF64" } else { "ELF32" }.to_string();
        let endian = if elf.little_endian { "Little" } else { "Big" }.to_string();

        let sections: Vec<SectionInfo> = elf.section_headers.iter().map(|s| {
            let name = elf.shdr_strtab.get_at(s.sh_name).unwrap_or("").to_string();
            SectionInfo {
                name,
                virtual_size: s.sh_size,
                raw_size: s.sh_size,
                characteristics: vec![],
                entropy: 0.0,
            }
        }).collect();

        let interpreter = elf.interpreter.map(|i| i.to_string());

        ElfInfo {
            machine,
            class,
            endian,
            entry_point: elf.entry,
            sections,
            program_headers: vec![],
            is_dynamic: elf.is_lib,
            interpreter,
        }
    }

    /// Extracts imports from ELF file
    fn extract_elf_imports(&self, elf: &elf::Elf) -> Vec<ImportInfo> {
        let mut imports = Vec::new();

        for sym in &elf.dynsyms {
            if sym.is_import() {
                if let Some(name) = elf.dynstrtab.get_at(sym.st_name) {
                    imports.push(ImportInfo {
                        library: "libc.so.6".to_string(), // Simplified
                        function: name.to_string(),
                        is_ordinal: false,
                    });
                }
            }
        }

        imports
    }

    /// Extracts exports from ELF file
    fn extract_elf_exports(&self, elf: &elf::Elf) -> Vec<ExportInfo> {
        let mut exports = Vec::new();

        for (i, sym) in elf.dynsyms.iter().enumerate() {
            if !sym.is_import() && sym.st_value != 0 {
                if let Some(name) = elf.dynstrtab.get_at(sym.st_name) {
                    exports.push(ExportInfo {
                        name: name.to_string(),
                        ordinal: i as u32,
                        rva: sym.st_value,
                    });
                }
            }
        }

        exports
    }

    /// Extracts printable strings from binary data
    ///
    /// # Algorithm
    /// 1. Scan for sequences of printable ASCII characters
    /// 2. Keep sequences longer than min_length
    /// 3. Also scan for UTF-16LE (wide) strings
    /// 4. Categorize interesting strings
    fn extract_strings(&self, data: &[u8], min_length: usize) -> Vec<ExtractedString> {
        let mut strings = Vec::new();
        let mut current = String::new();
        let mut start_offset = 0;

        // Extract ASCII strings
        for (i, &byte) in data.iter().enumerate() {
            if byte >= 0x20 && byte < 0x7F {
                if current.is_empty() {
                    start_offset = i;
                }
                current.push(byte as char);
            } else if current.len() >= min_length {
                let category = self.categorize_string(&current);
                strings.push(ExtractedString {
                    value: current.clone(),
                    offset: start_offset,
                    string_type: StringType::Ascii,
                    category,
                });
                current.clear();
            } else {
                current.clear();
            }
        }

        // Handle last string
        if current.len() >= min_length {
            let category = self.categorize_string(&current);
            strings.push(ExtractedString {
                value: current,
                offset: start_offset,
                string_type: StringType::Ascii,
                category,
            });
        }

        strings
    }

    /// Categorizes a string based on patterns
    fn categorize_string(&self, s: &str) -> Option<StringCategory> {
        // URL check
        if s.starts_with("http://") || s.starts_with("https://") {
            return Some(StringCategory::Url);
        }

        // IP address check (simple pattern)
        if s.chars().all(|c| c.is_ascii_digit() || c == '.') {
            let parts: Vec<&str> = s.split('.').collect();
            if parts.len() == 4 && parts.iter().all(|p| p.parse::<u8>().is_ok()) {
                return Some(StringCategory::IpAddress);
            }
        }

        // Registry key check
        if s.starts_with("HKEY_") || s.contains("\\Software\\") {
            return Some(StringCategory::RegistryKey);
        }

        // File path check
        if s.contains(":\\") || s.starts_with("/") {
            return Some(StringCategory::FilePath);
        }

        // Command check
        if s.contains("cmd.exe") || s.contains("powershell") {
            return Some(StringCategory::Command);
        }

        None
    }

    /// Identifies suspicious indicators
    fn find_indicators(
        &self,
        file_info: &FileInfo,
        imports: &[ImportInfo],
        strings: &[ExtractedString],
    ) -> Vec<Indicator> {
        let mut indicators = Vec::new();

        // Check entropy
        if file_info.entropy > 7.0 {
            indicators.push(Indicator {
                name: "HIGH_ENTROPY".to_string(),
                description: format!(
                    "File has high entropy ({:.2}), indicating possible packing or encryption",
                    file_info.entropy
                ),
                severity: Severity::Medium,
                category: "packing".to_string(),
            });
        }

        // Check suspicious imports
        for import in imports {
            if self.suspicious_imports.contains(&import.function.as_str()) {
                indicators.push(Indicator {
                    name: format!("SUSPICIOUS_IMPORT_{}", import.function.to_uppercase()),
                    description: format!(
                        "Imports suspicious function: {} from {}",
                        import.function, import.library
                    ),
                    severity: Severity::Medium,
                    category: "imports".to_string(),
                });
            }
        }

        // Check for IP addresses in strings
        for s in strings {
            if s.category == Some(StringCategory::IpAddress) {
                indicators.push(Indicator {
                    name: "EMBEDDED_IP".to_string(),
                    description: format!("Contains embedded IP address: {}", s.value),
                    severity: Severity::Low,
                    category: "network".to_string(),
                });
            }

            if s.category == Some(StringCategory::Command) {
                indicators.push(Indicator {
                    name: "COMMAND_EXECUTION".to_string(),
                    description: format!("References command interpreter: {}", s.value),
                    severity: Severity::Medium,
                    category: "execution".to_string(),
                });
            }
        }

        indicators
    }

    /// Calculates overall risk score
    fn calculate_risk_score(&self, file_info: &FileInfo, indicators: &[Indicator]) -> u32 {
        let mut score = 0u32;

        // Base entropy score
        if file_info.entropy > 7.5 {
            score += 20;
        } else if file_info.entropy > 7.0 {
            score += 10;
        }

        // Score from indicators
        for indicator in indicators {
            score += match indicator.severity {
                Severity::Low => 5,
                Severity::Medium => 15,
                Severity::High => 30,
                Severity::Critical => 50,
            };
        }

        // Cap at 100
        score.min(100)
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// MAIN FUNCTION
// ═══════════════════════════════════════════════════════════════════════════

fn main() {
    let args = Args::parse();

    println!("╔════════════════════════════════════════════════════════════════╗");
    println!("║             STATIC BINARY ANALYZER                              ║");
    println!("╚════════════════════════════════════════════════════════════════╝\n");

    let analyzer = StaticAnalyzer::new();

    match analyzer.analyze(&args.file) {
        Ok(report) => {
            // File Info
            println!("[*] File Information");
            println!("    Path:    {}", report.file_info.path);
            println!("    Size:    {} bytes", report.file_info.size);
            println!("    SHA256:  {}", report.file_info.sha256);
            println!("    MD5:     {}", report.file_info.md5);
            println!("    Type:    {:?}", report.file_info.file_type);
            println!("    Entropy: {:.4}", report.file_info.entropy);

            // PE/ELF Info
            if let Some(pe) = &report.pe_info {
                println!("\n[*] PE Information");
                println!("    Machine:      {}", pe.machine);
                println!("    Sections:     {}", pe.num_sections);
                println!("    Entry Point:  0x{:X}", pe.entry_point);
                println!("    Image Base:   0x{:X}", pe.image_base);
                println!("    Subsystem:    {}", pe.subsystem);
                println!("    Timestamp:    {}", pe.timestamp);

                if args.verbose {
                    println!("\n    Sections:");
                    for section in &pe.sections {
                        println!("      {} (V:{} R:{}) {:?}",
                            section.name,
                            section.virtual_size,
                            section.raw_size,
                            section.characteristics
                        );
                    }
                }
            }

            if let Some(elf) = &report.elf_info {
                println!("\n[*] ELF Information");
                println!("    Machine:     {}", elf.machine);
                println!("    Class:       {}", elf.class);
                println!("    Endian:      {}", elf.endian);
                println!("    Entry Point: 0x{:X}", elf.entry_point);
                println!("    Dynamic:     {}", elf.is_dynamic);
                if let Some(interp) = &elf.interpreter {
                    println!("    Interpreter: {}", interp);
                }
            }

            // Imports
            println!("\n[*] Imports: {} total", report.imports.len());
            if args.verbose && !report.imports.is_empty() {
                for import in report.imports.iter().take(20) {
                    println!("    {} -> {}", import.library, import.function);
                }
                if report.imports.len() > 20 {
                    println!("    ... and {} more", report.imports.len() - 20);
                }
            }

            // Exports
            if !report.exports.is_empty() {
                println!("\n[*] Exports: {} total", report.exports.len());
            }

            // Interesting Strings
            let interesting: Vec<_> = report.strings.iter()
                .filter(|s| s.category.is_some())
                .collect();
            if !interesting.is_empty() {
                println!("\n[*] Interesting Strings:");
                for s in interesting.iter().take(10) {
                    println!("    [{:?}] {}", s.category.as_ref().unwrap(), s.value);
                }
            }

            // Indicators
            if !report.indicators.is_empty() {
                println!("\n[!] Security Indicators:");
                for ind in &report.indicators {
                    let severity_str = match ind.severity {
                        Severity::Low => "LOW",
                        Severity::Medium => "MEDIUM",
                        Severity::High => "HIGH",
                        Severity::Critical => "CRITICAL",
                    };
                    println!("    [{}] {}: {}", severity_str, ind.name, ind.description);
                }
            }

            // Risk Score
            println!("\n[*] Risk Score: {}/100", report.risk_score);
            let verdict = match report.risk_score {
                0..=20 => "CLEAN",
                21..=50 => "SUSPICIOUS",
                51..=80 => "LIKELY MALICIOUS",
                _ => "MALICIOUS",
            };
            println!("[*] Verdict: {}", verdict);
        }
        Err(e) => {
            eprintln!("[-] Analysis failed: {}", e);
            std::process::exit(1);
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_entropy_calculation() {
        // All same bytes should have 0 entropy
        let uniform = vec![0u8; 1000];
        assert!(FileInfo::calculate_entropy(&uniform) < 0.001);

        // Random-ish data should have higher entropy
        let random: Vec<u8> = (0..=255).cycle().take(1000).collect();
        assert!(FileInfo::calculate_entropy(&random) > 7.0);
    }

    #[test]
    fn test_file_type_detection() {
        // PE magic bytes
        let pe_data = b"MZ\x00\x00".to_vec();
        // Need proper PE header for full detection

        // ELF magic bytes
        let mut elf_data = vec![0x7F, 0x45, 0x4C, 0x46, 0x02]; // ELF64
        elf_data.resize(64, 0);
        assert_eq!(FileInfo::detect_file_type(&elf_data), FileType::ELF64);
    }

    #[test]
    fn test_string_extraction() {
        let analyzer = StaticAnalyzer::new();
        let data = b"Hello, this is a test string\x00\x00garbage\x00http://example.com";
        let strings = analyzer.extract_strings(data, 4);

        assert!(strings.iter().any(|s| s.value.contains("Hello")));
        assert!(strings.iter().any(|s| s.category == Some(StringCategory::Url)));
    }
}
```

## Line-by-Line Breakdown

### CLI Argument Parsing

```rust
#[derive(Parser, Debug)]
#[command(name = "static-analyzer")]
struct Args {
    #[arg(short, long)]
    file: String,
}
```

**Line-by-Line:**
1. `#[derive(Parser, Debug)]` - Automatically generates CLI parsing code from the struct
2. `#[command(name = ...)]` - Sets the program name shown in --help
3. `#[arg(short, long)]` - Creates both `-f` and `--file` options
4. `file: String` - The field type determines argument type

### Entropy Calculation

```rust
let mut freq = [0u64; 256];
for &byte in data {
    freq[byte as usize] += 1;
}
```

**Line-by-Line:**
1. `[0u64; 256]` - Array of 256 zeros (one counter per possible byte value)
2. `for &byte in data` - Iterate with dereferencing (byte is u8, not &u8)
3. `byte as usize` - Convert byte to index (0-255)
4. `+= 1` - Increment the frequency counter

### Import Analysis

```rust
if self.suspicious_imports.contains(&import.function.as_str()) {
    indicators.push(Indicator { ... });
}
```

**What's Happening:**
1. `&import.function.as_str()` - Convert String to &str for comparison
2. `contains()` - Checks if the slice contains this string
3. `push()` - Adds to the indicators vector if found

## Red Team Perspective

### Evasion Techniques
```
1. API Hashing
   └─► Instead of importing by name, resolve APIs at runtime using hashes

2. Packing/Encryption
   └─► Encrypt the payload to hide strings and imports

3. Import obfuscation
   └─► Import by ordinal instead of name
   └─► Use LoadLibrary/GetProcAddress dynamically

4. String encryption
   └─► XOR, AES, or custom encoding for strings

5. Section name randomization
   └─► Change default section names (.text → .xyz)
```

### Testing Your Evasion
- Submit samples to VirusTotal to test detection
- Use local sandboxes (Cuckoo, CAPE)
- Check with multiple AV products

## Blue Team Perspective

### Improving Detection
```
1. Add YARA integration
   └─► Pattern matching beyond simple strings

2. Import hash (imphash) checking
   └─► Compare against known malware import tables

3. Certificate validation
   └─► Check if signed and by whom

4. Fuzzy hashing (ssdeep)
   └─► Detect variants of known malware

5. Machine learning
   └─► Train models on PE features
```

### Integration Points
- SIEM integration for automated scanning
- CI/CD pipeline integration
- Email gateway attachment scanning
- EDR integration for endpoint scanning

## Exercises

### Exercise 1: Add Section Entropy
Modify the analyzer to calculate entropy for each section individually. High entropy in the `.text` section is suspicious.

### Exercise 2: Add PEiD Signatures
Implement detection of common packers (UPX, ASPack, etc.) by checking for their signatures.

### Exercise 3: Import Hash (imphash)
Calculate the import hash (MD5 of sorted imports) for PE files. This helps identify malware families.

### Exercise 4: Resource Extraction
Extract embedded resources (icons, manifests, etc.) from PE files for further analysis.

### Exercise 5: Export Analysis
Add detection for suspicious exports often used in DLL side-loading attacks.

---

**← Previous:** [Chapter 8 Overview](../README.md) | **Next →** [MA02: Dynamic Analysis](../02_Dynamic_Analysis/README.md)
