# Chapter 8: Malware Analysis with Rust

## Overview

Learn to build malware analysis tools in Rust for static analysis, dynamic analysis, behavioral detection, and signature matching.

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      MALWARE ANALYSIS PIPELINE                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   ┌─────────────┐   ┌─────────────┐   ┌─────────────┐   ┌─────────────┐    │
│   │   STATIC    │   │   DYNAMIC   │   │ BEHAVIORAL  │   │  SIGNATURE  │    │
│   │  ANALYSIS   │──▶│  ANALYSIS   │──▶│  ANALYSIS   │──▶│  MATCHING   │    │
│   │             │   │             │   │             │   │             │    │
│   │ • PE/ELF    │   │ • Sandbox   │   │ • API calls │   │ • YARA      │    │
│   │ • Strings   │   │ • Syscalls  │   │ • Network   │   │ • Hashes    │    │
│   │ • Imports   │   │ • Memory    │   │ • Files     │   │ • Patterns  │    │
│   │ • Headers   │   │ • Hooks     │   │ • Registry  │   │ • ML/AI     │    │
│   └─────────────┘   └─────────────┘   └─────────────┘   └─────────────┘    │
│                                                                              │
│                              │                                               │
│                              ▼                                               │
│                    ┌─────────────────┐                                      │
│                    │    VERDICT      │                                      │
│                    │  ───────────    │                                      │
│                    │  • Clean        │                                      │
│                    │  • Suspicious   │                                      │
│                    │  • Malicious    │                                      │
│                    │  • Classification│                                      │
│                    └─────────────────┘                                      │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

## Sections

| Section | Focus | Key Tools Built |
|---------|-------|-----------------|
| [01_Static_Analysis](01_Static_Analysis/) | PE/ELF parsing, strings, imports | Binary analyzer |
| [02_Dynamic_Analysis](02_Dynamic_Analysis/) | Syscall tracing, memory analysis | Process monitor |
| [03_Behavioral_Analysis](03_Behavioral_Analysis/) | API monitoring, network detection | Behavior engine |
| [04_Signature_Detection](04_Signature_Detection/) | YARA, hash matching, pattern detection | Signature scanner |

## Learning Objectives

By the end of this chapter, you will be able to:
1. Parse PE and ELF binary formats
2. Extract and analyze strings, imports, exports
3. Detect packed/obfuscated executables
4. Build YARA rule engines
5. Create behavioral detection systems
6. Understand malware classification techniques

## Prerequisites

- Completed Basic and Intermediate Rust levels
- Understanding of binary formats (PE/ELF basics)
- Familiarity with system calls and APIs

## Key Crates Used

```toml
[dependencies]
goblin = "0.7"          # PE/ELF/Mach-O parsing
yara = "0.25"           # YARA rule matching
sha2 = "0.10"           # Hashing
md-5 = "0.10"           # MD5 hashing
regex = "1.10"          # Pattern matching
walkdir = "2.4"         # Directory traversal
serde = "1.0"           # Serialization
serde_json = "1.0"      # JSON output
clap = "4.4"            # CLI parsing
```

---

## Teaching Methodology

Each project in this chapter follows a structured teaching approach:

### 1. Concept Introduction
```
What is the technique?
Why is it important for malware analysis?
Real-world applications
```

### 2. Code Implementation
```rust
// Full working code with extensive comments
```

### 3. Line-by-Line Breakdown
```
Each significant line explained:
- What it does
- Why it's written this way
- How it connects to the bigger picture
```

### 4. Struct and Function Deep Dive
```
Detailed explanation of:
- Data structures and their fields
- Function signatures and return types
- Method implementations
- Trait implementations
```

### 5. Red Team / Blue Team Perspectives
```
How attackers might evade this technique
How defenders can improve detection
```

### 6. Exercises
```
Hands-on challenges to reinforce learning
```

---

## Quick Start: Simple Malware Scanner

Here's a preview of what you'll build. This basic scanner demonstrates the core concepts:

```rust
//! Simple Malware Scanner - Preview
//! This shows the structure of tools you'll build in this chapter

use std::fs;
use std::path::Path;
use sha2::{Sha256, Digest};

// ═══════════════════════════════════════════════════════════════════════════
// STRUCT DEFINITIONS - Data structures that hold our analysis data
// ═══════════════════════════════════════════════════════════════════════════

/// Represents a file being analyzed
///
/// # Fields Explained
/// - `path`: Where the file lives on disk
/// - `size`: File size in bytes (useful for quick filtering)
/// - `sha256`: Cryptographic hash for identification
/// - `file_type`: What kind of file this is (PE, ELF, etc.)
#[derive(Debug, Clone)]
struct AnalysisTarget {
    path: String,          // String stores owned path data
    size: u64,             // u64 = unsigned 64-bit, holds files up to 18 exabytes
    sha256: String,        // Hash as hex string
    file_type: FileType,   // Enum for type safety
}

/// Enumeration of file types we can analyze
///
/// # Why Use an Enum?
/// - Type safety: Compiler ensures we handle all cases
/// - Clear intent: Self-documenting code
/// - Pattern matching: Easy to branch on type
#[derive(Debug, Clone, PartialEq)]
enum FileType {
    PE,          // Windows Portable Executable
    ELF,         // Linux Executable and Linkable Format
    MachO,       // macOS Mach Object
    Script,      // Shell scripts, batch files
    Unknown,     // Unrecognized format
}

/// Result of malware analysis
///
/// # Design Choice
/// Using Option<T> for fields that might not be present
/// rather than empty strings - more idiomatic Rust
#[derive(Debug)]
struct AnalysisResult {
    target: AnalysisTarget,
    verdict: Verdict,
    score: u32,                      // 0-100 threat score
    detections: Vec<Detection>,      // What we found
    indicators: Vec<String>,         // IOCs extracted
}

/// Classification of the analyzed file
#[derive(Debug, Clone, PartialEq)]
enum Verdict {
    Clean,
    Suspicious,
    Malicious,
    Unknown,
}

/// A single detection finding
#[derive(Debug, Clone)]
struct Detection {
    name: String,           // Detection name (e.g., "Trojan.Generic")
    category: String,       // Category (e.g., "signature", "heuristic")
    confidence: u32,        // 0-100 confidence level
    description: String,    // Human-readable description
}

// ═══════════════════════════════════════════════════════════════════════════
// IMPLEMENTATION BLOCKS - Methods attached to our structs
// ═══════════════════════════════════════════════════════════════════════════

impl AnalysisTarget {
    /// Creates a new AnalysisTarget from a file path
    ///
    /// # Parameters
    /// - `path`: Path to the file (accepts anything that can become a Path)
    ///
    /// # Returns
    /// - `Result<Self, String>`: Either the target or an error message
    ///
    /// # Teaching Note
    /// We use `AsRef<Path>` as a trait bound. This means the function
    /// accepts &str, String, PathBuf, or Path - anything that can be
    /// referenced as a Path. This is idiomatic Rust for flexible APIs.
    fn new<P: AsRef<Path>>(path: P) -> Result<Self, String> {
        // Convert the generic path to a Path reference
        let path = path.as_ref();

        // Read file metadata - this doesn't read the whole file
        let metadata = fs::metadata(path)
            .map_err(|e| format!("Failed to read metadata: {}", e))?;

        // Read file contents for hashing
        let contents = fs::read(path)
            .map_err(|e| format!("Failed to read file: {}", e))?;

        // Calculate SHA256 hash
        let hash = Sha256::digest(&contents);
        let sha256 = format!("{:x}", hash);  // :x formats as lowercase hex

        // Detect file type from magic bytes
        let file_type = Self::detect_type(&contents);

        Ok(AnalysisTarget {
            path: path.to_string_lossy().to_string(),
            size: metadata.len(),
            sha256,
            file_type,
        })
    }

    /// Detects file type from magic bytes (file signature)
    ///
    /// # Magic Bytes Explained
    /// Most file formats start with specific bytes that identify them:
    /// - PE files: "MZ" (0x4D, 0x5A) - Mark Zbikowski's initials
    /// - ELF files: 0x7F "ELF"
    /// - Scripts: "#!" (shebang)
    ///
    /// # Why This Matters
    /// Malware often disguises file extensions. Magic bytes reveal true type.
    fn detect_type(data: &[u8]) -> FileType {
        if data.len() < 4 {
            return FileType::Unknown;
        }

        // Check for PE (Windows executable)
        // MZ header followed by PE signature at offset in header
        if data[0] == 0x4D && data[1] == 0x5A {  // "MZ"
            return FileType::PE;
        }

        // Check for ELF (Linux executable)
        // 0x7F followed by "ELF"
        if data[0] == 0x7F && data[1] == 0x45 &&
           data[2] == 0x4C && data[3] == 0x46 {
            return FileType::ELF;
        }

        // Check for Mach-O (macOS executable)
        // Multiple magic values for 32/64-bit
        if (data[0] == 0xFE && data[1] == 0xED && data[2] == 0xFA) ||
           (data[0] == 0xCF && data[1] == 0xFA && data[2] == 0xED) {
            return FileType::MachO;
        }

        // Check for script (shebang)
        if data[0] == 0x23 && data[1] == 0x21 {  // "#!"
            return FileType::Script;
        }

        FileType::Unknown
    }
}

impl AnalysisResult {
    /// Calculates the overall verdict based on detections
    ///
    /// # Scoring Logic
    /// - Each detection adds to the score based on confidence
    /// - Thresholds determine final verdict
    /// - This is a simplified version; real systems are more complex
    fn calculate_verdict(&mut self) {
        // Sum up weighted scores from all detections
        let total_score: u32 = self.detections.iter()
            .map(|d| d.confidence)
            .sum();

        // Average if we have detections
        self.score = if !self.detections.is_empty() {
            total_score / self.detections.len() as u32
        } else {
            0
        };

        // Determine verdict based on score
        self.verdict = match self.score {
            0..=10 => Verdict::Clean,
            11..=50 => Verdict::Suspicious,
            51..=100 => Verdict::Malicious,
            _ => Verdict::Unknown,
        };
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// THE MALWARE SCANNER - Main analysis engine
// ═══════════════════════════════════════════════════════════════════════════

/// The main scanner that coordinates analysis
///
/// # Architecture
/// This follows the Strategy pattern - different analyzers can be
/// plugged in for different analysis types.
struct MalwareScanner {
    /// Known malicious hashes (IOC database)
    known_hashes: Vec<String>,

    /// Suspicious strings to look for
    suspicious_strings: Vec<String>,
}

impl MalwareScanner {
    /// Creates a new scanner with default detection rules
    fn new() -> Self {
        MalwareScanner {
            // In production, load from external database
            known_hashes: vec![
                // Example known bad hashes (these are fake)
                "d41d8cd98f00b204e9800998ecf8427e".to_string(),
            ],
            suspicious_strings: vec![
                // Strings commonly found in malware
                "CreateRemoteThread".to_string(),
                "VirtualAllocEx".to_string(),
                "WriteProcessMemory".to_string(),
                "NtUnmapViewOfSection".to_string(),
                "powershell -enc".to_string(),
                "cmd.exe /c".to_string(),
                "WScript.Shell".to_string(),
                "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run".to_string(),
            ],
        }
    }

    /// Analyzes a file and returns the result
    ///
    /// # Analysis Steps
    /// 1. Create analysis target (read file, hash it)
    /// 2. Check against known malicious hashes
    /// 3. Extract and analyze strings
    /// 4. Calculate final verdict
    fn analyze<P: AsRef<Path>>(&self, path: P) -> Result<AnalysisResult, String> {
        // Step 1: Create the analysis target
        let target = AnalysisTarget::new(&path)?;

        let mut result = AnalysisResult {
            target: target.clone(),
            verdict: Verdict::Unknown,
            score: 0,
            detections: Vec::new(),
            indicators: Vec::new(),
        };

        // Step 2: Check known malicious hashes
        if self.known_hashes.contains(&target.sha256) {
            result.detections.push(Detection {
                name: "Known.Malware.Hash".to_string(),
                category: "signature".to_string(),
                confidence: 100,
                description: "File hash matches known malware".to_string(),
            });
        }

        // Step 3: Read file and check for suspicious strings
        if let Ok(contents) = fs::read(&path) {
            self.check_strings(&contents, &mut result);
        }

        // Step 4: Calculate final verdict
        result.calculate_verdict();

        Ok(result)
    }

    /// Searches for suspicious strings in file content
    ///
    /// # String Analysis
    /// Malware often contains identifiable strings:
    /// - API names for malicious functions
    /// - C2 server addresses
    /// - Encryption keys
    /// - Debug messages left by authors
    fn check_strings(&self, data: &[u8], result: &mut AnalysisResult) {
        // Convert to string, replacing invalid UTF-8
        let content = String::from_utf8_lossy(data);

        for suspicious in &self.suspicious_strings {
            if content.contains(suspicious) {
                result.detections.push(Detection {
                    name: format!("Suspicious.String.{}",
                        suspicious.chars()
                            .filter(|c| c.is_alphanumeric())
                            .collect::<String>()),
                    category: "heuristic".to_string(),
                    confidence: 40,
                    description: format!("Contains suspicious string: {}", suspicious),
                });

                // Add to indicators of compromise
                result.indicators.push(suspicious.clone());
            }
        }
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// MAIN FUNCTION - Entry point
// ═══════════════════════════════════════════════════════════════════════════

fn main() {
    println!("╔════════════════════════════════════════════════════════════╗");
    println!("║           MALWARE SCANNER - Educational Demo               ║");
    println!("╚════════════════════════════════════════════════════════════╝\n");

    let scanner = MalwareScanner::new();

    // Example: Analyze a file (use any file for testing)
    let test_file = "/bin/ls";  // Safe file for demo

    match scanner.analyze(test_file) {
        Ok(result) => {
            println!("[*] Analysis Results");
            println!("    File: {}", result.target.path);
            println!("    Size: {} bytes", result.target.size);
            println!("    SHA256: {}", result.target.sha256);
            println!("    Type: {:?}", result.target.file_type);
            println!("    Verdict: {:?}", result.verdict);
            println!("    Score: {}/100", result.score);

            if !result.detections.is_empty() {
                println!("\n[!] Detections:");
                for det in &result.detections {
                    println!("    - {} ({}%): {}",
                        det.name, det.confidence, det.description);
                }
            }
        }
        Err(e) => {
            eprintln!("[-] Analysis failed: {}", e);
        }
    }
}
```

---

## Understanding Rust Concepts for Malware Analysis

### Why Rust for Malware Analysis?

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    RUST ADVANTAGES FOR MALWARE ANALYSIS                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  1. MEMORY SAFETY                                                           │
│     └─► Analyze malicious files without risking memory corruption           │
│                                                                              │
│  2. PERFORMANCE                                                             │
│     └─► Hash millions of files quickly                                      │
│     └─► Real-time packet inspection                                         │
│                                                                              │
│  3. CROSS-PLATFORM                                                          │
│     └─► Analyze Windows PE on Linux                                         │
│     └─► Same codebase for all platforms                                     │
│                                                                              │
│  4. STRONG TYPE SYSTEM                                                      │
│     └─► Catch errors at compile time                                        │
│     └─► Model complex data structures safely                                │
│                                                                              │
│  5. NO RUNTIME                                                              │
│     └─► Single binary deployment                                            │
│     └─► No dependencies on target systems                                   │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Key Rust Patterns Used

#### Pattern 1: Error Handling with Result
```rust
// Instead of exceptions, Rust uses Result<T, E>
fn analyze_file(path: &str) -> Result<Analysis, AnalysisError> {
    let data = fs::read(path)?;  // ? propagates errors
    // ... analysis ...
    Ok(analysis)
}

// Caller must handle the result
match analyze_file("suspicious.exe") {
    Ok(result) => println!("Analysis: {:?}", result),
    Err(e) => eprintln!("Failed: {}", e),
}
```

#### Pattern 2: Trait-Based Polymorphism
```rust
// Define a trait for analyzers
trait Analyzer {
    fn analyze(&self, data: &[u8]) -> Vec<Detection>;
    fn name(&self) -> &str;
}

// Implement for different analysis types
struct StringAnalyzer;
struct ImportAnalyzer;
struct EntropyAnalyzer;

impl Analyzer for StringAnalyzer {
    fn analyze(&self, data: &[u8]) -> Vec<Detection> {
        // String analysis implementation
    }
    fn name(&self) -> &str { "StringAnalyzer" }
}

// Use trait objects for runtime polymorphism
fn run_analyzers(data: &[u8], analyzers: &[Box<dyn Analyzer>]) {
    for analyzer in analyzers {
        let detections = analyzer.analyze(data);
        println!("{}: {} detections", analyzer.name(), detections.len());
    }
}
```

#### Pattern 3: Builder Pattern for Configuration
```rust
struct ScannerBuilder {
    hash_check: bool,
    string_check: bool,
    import_check: bool,
    timeout: Duration,
}

impl ScannerBuilder {
    fn new() -> Self {
        Self {
            hash_check: true,
            string_check: true,
            import_check: true,
            timeout: Duration::from_secs(30),
        }
    }

    fn with_hash_check(mut self, enabled: bool) -> Self {
        self.hash_check = enabled;
        self
    }

    fn with_timeout(mut self, timeout: Duration) -> Self {
        self.timeout = timeout;
        self
    }

    fn build(self) -> Scanner {
        Scanner {
            config: self,
            // ... other initialization
        }
    }
}

// Usage
let scanner = ScannerBuilder::new()
    .with_hash_check(true)
    .with_timeout(Duration::from_secs(60))
    .build();
```

---

Continue to the specific analysis sections for detailed implementations.

[→ 01_Static_Analysis](01_Static_Analysis/) | [→ 02_Dynamic_Analysis](02_Dynamic_Analysis/) | [→ 03_Behavioral_Analysis](03_Behavioral_Analysis/) | [→ 04_Signature_Detection](04_Signature_Detection/)
