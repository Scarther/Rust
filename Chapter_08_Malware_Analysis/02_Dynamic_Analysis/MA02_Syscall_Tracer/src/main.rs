//! # System Call Tracer for Malware Analysis
//!
//! This tool traces system calls made by a process, similar to strace.
//! It's essential for dynamic malware analysis to understand what a suspicious
//! binary is doing at the kernel level.
//!
//! ## Malware Analysis Concepts
//!
//! **System Call Tracing**: Malware must interact with the operating system
//! to perform actions like file I/O, network communication, and process
//! manipulation. By tracing syscalls, we can observe:
//!
//! - File operations (open, read, write, unlink) - detecting file dropping/deletion
//! - Network operations (socket, connect, sendto) - detecting C2 communication
//! - Process operations (fork, execve, clone) - detecting process injection
//! - Memory operations (mmap, mprotect) - detecting code injection
//!
//! **ptrace**: The Linux ptrace system call allows one process to observe
//! and control another process's execution, including syscall interception.
//!
//! ## DEFENSIVE USE ONLY
//! This tool is designed for analyzing potentially malicious samples in
//! controlled environments (sandboxes, VMs) to understand their behavior.

use anyhow::{Context, Result};
use chrono::Local;
use clap::{Parser, ValueEnum};
use colored::*;
use nix::sys::ptrace;
use nix::sys::signal::Signal;
use nix::sys::wait::{waitpid, WaitStatus};
use nix::unistd::{fork, ForkResult, Pid};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::fs::File;
use std::io::{BufWriter, Write};
use std::os::unix::process::CommandExt;
use std::process::Command;
use std::time::Instant;

/// System Call Tracer - Dynamic Malware Analysis Tool
///
/// Traces system calls made by a process to understand its behavior.
/// Essential for analyzing suspicious binaries in controlled environments.
#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    /// Target process ID to trace (attach mode)
    #[arg(short, long)]
    pid: Option<i32>,

    /// Command to execute and trace
    #[arg(short, long)]
    command: Option<String>,

    /// Arguments for the command
    #[arg(short, long)]
    args: Vec<String>,

    /// Output format
    #[arg(short, long, value_enum, default_value = "text")]
    format: OutputFormat,

    /// Output file (stdout if not specified)
    #[arg(short = 'o', long)]
    output: Option<String>,

    /// Filter by syscall category
    #[arg(short = 'f', long)]
    filter: Option<SyscallCategory>,

    /// Show only suspicious syscalls (useful for malware analysis)
    #[arg(long)]
    suspicious_only: bool,

    /// Show memory contents for read/write operations
    #[arg(long)]
    show_memory: bool,

    /// Maximum number of syscalls to trace (0 = unlimited)
    #[arg(long, default_value = "0")]
    max_calls: usize,

    /// Verbose output with additional context
    #[arg(short, long)]
    verbose: bool,
}

/// Output format for syscall traces
#[derive(Debug, Clone, ValueEnum)]
enum OutputFormat {
    Text,
    Json,
    Csv,
}

/// Syscall categories for filtering
#[derive(Debug, Clone, ValueEnum, PartialEq, Eq, Serialize, Deserialize)]
enum SyscallCategory {
    File,
    Network,
    Process,
    Memory,
    System,
    All,
}

/// Represents a traced system call with its arguments and return value
#[derive(Debug, Clone, Serialize, Deserialize)]
struct SyscallEvent {
    /// Timestamp of the syscall
    timestamp: String,
    /// Process ID
    pid: i32,
    /// Syscall number
    syscall_num: u64,
    /// Syscall name
    syscall_name: String,
    /// Category of the syscall
    category: SyscallCategory,
    /// Arguments (as hex values)
    args: Vec<u64>,
    /// Return value
    return_value: Option<i64>,
    /// Whether this syscall is considered suspicious
    is_suspicious: bool,
    /// Additional notes for suspicious syscalls
    notes: Option<String>,
    /// Duration in microseconds
    duration_us: u64,
}

/// Mapping of x86_64 syscall numbers to names and categories
/// This is a subset of common syscalls relevant to malware analysis
struct SyscallInfo {
    name: &'static str,
    category: SyscallCategory,
    suspicious: bool,
    notes: &'static str,
}

/// Get syscall information from syscall number (x86_64 Linux)
///
/// This function maps syscall numbers to their names, categories, and
/// whether they're commonly used in malicious activities.
fn get_syscall_info(num: u64) -> SyscallInfo {
    // x86_64 syscall numbers - commonly observed in malware
    match num {
        // File operations - Category: File
        0 => SyscallInfo {
            name: "read",
            category: SyscallCategory::File,
            suspicious: false,
            notes: "Read from file descriptor",
        },
        1 => SyscallInfo {
            name: "write",
            category: SyscallCategory::File,
            suspicious: false,
            notes: "Write to file descriptor",
        },
        2 => SyscallInfo {
            name: "open",
            category: SyscallCategory::File,
            suspicious: false,
            notes: "Open file - check for sensitive paths",
        },
        3 => SyscallInfo {
            name: "close",
            category: SyscallCategory::File,
            suspicious: false,
            notes: "Close file descriptor",
        },
        4 => SyscallInfo {
            name: "stat",
            category: SyscallCategory::File,
            suspicious: false,
            notes: "Get file status",
        },
        5 => SyscallInfo {
            name: "fstat",
            category: SyscallCategory::File,
            suspicious: false,
            notes: "Get file status by fd",
        },
        6 => SyscallInfo {
            name: "lstat",
            category: SyscallCategory::File,
            suspicious: false,
            notes: "Get symbolic link status",
        },
        8 => SyscallInfo {
            name: "lseek",
            category: SyscallCategory::File,
            suspicious: false,
            notes: "Seek in file",
        },
        17 => SyscallInfo {
            name: "pread64",
            category: SyscallCategory::File,
            suspicious: false,
            notes: "Read from file at offset",
        },
        18 => SyscallInfo {
            name: "pwrite64",
            category: SyscallCategory::File,
            suspicious: false,
            notes: "Write to file at offset",
        },
        21 => SyscallInfo {
            name: "access",
            category: SyscallCategory::File,
            suspicious: false,
            notes: "Check file access - may check for sandboxes",
        },
        22 => SyscallInfo {
            name: "pipe",
            category: SyscallCategory::File,
            suspicious: false,
            notes: "Create pipe",
        },
        32 => SyscallInfo {
            name: "dup",
            category: SyscallCategory::File,
            suspicious: false,
            notes: "Duplicate file descriptor",
        },
        33 => SyscallInfo {
            name: "dup2",
            category: SyscallCategory::File,
            suspicious: false,
            notes: "Duplicate file descriptor to specific fd",
        },
        72 => SyscallInfo {
            name: "fcntl",
            category: SyscallCategory::File,
            suspicious: false,
            notes: "File control operations",
        },
        77 => SyscallInfo {
            name: "ftruncate",
            category: SyscallCategory::File,
            suspicious: false,
            notes: "Truncate file",
        },
        78 => SyscallInfo {
            name: "getdents",
            category: SyscallCategory::File,
            suspicious: false,
            notes: "Read directory entries",
        },
        79 => SyscallInfo {
            name: "getcwd",
            category: SyscallCategory::File,
            suspicious: false,
            notes: "Get current directory",
        },
        80 => SyscallInfo {
            name: "chdir",
            category: SyscallCategory::File,
            suspicious: false,
            notes: "Change directory",
        },
        82 => SyscallInfo {
            name: "rename",
            category: SyscallCategory::File,
            suspicious: true,
            notes: "Rename file - may hide malware",
        },
        83 => SyscallInfo {
            name: "mkdir",
            category: SyscallCategory::File,
            suspicious: false,
            notes: "Create directory",
        },
        84 => SyscallInfo {
            name: "rmdir",
            category: SyscallCategory::File,
            suspicious: true,
            notes: "Remove directory - potential cleanup",
        },
        85 => SyscallInfo {
            name: "creat",
            category: SyscallCategory::File,
            suspicious: true,
            notes: "Create file - may drop malware",
        },
        86 => SyscallInfo {
            name: "link",
            category: SyscallCategory::File,
            suspicious: true,
            notes: "Create hard link - persistence mechanism",
        },
        87 => SyscallInfo {
            name: "unlink",
            category: SyscallCategory::File,
            suspicious: true,
            notes: "Delete file - evidence destruction",
        },
        88 => SyscallInfo {
            name: "symlink",
            category: SyscallCategory::File,
            suspicious: true,
            notes: "Create symbolic link - potential hijacking",
        },
        89 => SyscallInfo {
            name: "readlink",
            category: SyscallCategory::File,
            suspicious: false,
            notes: "Read symbolic link",
        },
        90 => SyscallInfo {
            name: "chmod",
            category: SyscallCategory::File,
            suspicious: true,
            notes: "Change file mode - may set executable",
        },
        91 => SyscallInfo {
            name: "fchmod",
            category: SyscallCategory::File,
            suspicious: true,
            notes: "Change file mode by fd",
        },
        92 => SyscallInfo {
            name: "chown",
            category: SyscallCategory::File,
            suspicious: true,
            notes: "Change file owner - privilege escalation",
        },
        257 => SyscallInfo {
            name: "openat",
            category: SyscallCategory::File,
            suspicious: false,
            notes: "Open file relative to directory fd",
        },

        // Memory operations - Category: Memory
        9 => SyscallInfo {
            name: "mmap",
            category: SyscallCategory::Memory,
            suspicious: true,
            notes: "Memory map - may be used for code injection",
        },
        10 => SyscallInfo {
            name: "mprotect",
            category: SyscallCategory::Memory,
            suspicious: true,
            notes: "Change memory protection - code injection indicator",
        },
        11 => SyscallInfo {
            name: "munmap",
            category: SyscallCategory::Memory,
            suspicious: false,
            notes: "Unmap memory",
        },
        12 => SyscallInfo {
            name: "brk",
            category: SyscallCategory::Memory,
            suspicious: false,
            notes: "Change data segment size",
        },
        25 => SyscallInfo {
            name: "mremap",
            category: SyscallCategory::Memory,
            suspicious: true,
            notes: "Remap memory - potential evasion",
        },
        26 => SyscallInfo {
            name: "msync",
            category: SyscallCategory::Memory,
            suspicious: false,
            notes: "Sync memory to disk",
        },
        27 => SyscallInfo {
            name: "mincore",
            category: SyscallCategory::Memory,
            suspicious: true,
            notes: "Check if pages in core - sandbox detection",
        },
        28 => SyscallInfo {
            name: "madvise",
            category: SyscallCategory::Memory,
            suspicious: false,
            notes: "Memory advice",
        },

        // Network operations - Category: Network
        41 => SyscallInfo {
            name: "socket",
            category: SyscallCategory::Network,
            suspicious: true,
            notes: "Create socket - C2 communication setup",
        },
        42 => SyscallInfo {
            name: "connect",
            category: SyscallCategory::Network,
            suspicious: true,
            notes: "Connect to remote - C2 communication",
        },
        43 => SyscallInfo {
            name: "accept",
            category: SyscallCategory::Network,
            suspicious: true,
            notes: "Accept connection - backdoor indicator",
        },
        44 => SyscallInfo {
            name: "sendto",
            category: SyscallCategory::Network,
            suspicious: true,
            notes: "Send data - data exfiltration",
        },
        45 => SyscallInfo {
            name: "recvfrom",
            category: SyscallCategory::Network,
            suspicious: true,
            notes: "Receive data - C2 commands",
        },
        46 => SyscallInfo {
            name: "sendmsg",
            category: SyscallCategory::Network,
            suspicious: true,
            notes: "Send message - data exfiltration",
        },
        47 => SyscallInfo {
            name: "recvmsg",
            category: SyscallCategory::Network,
            suspicious: true,
            notes: "Receive message - C2 commands",
        },
        48 => SyscallInfo {
            name: "shutdown",
            category: SyscallCategory::Network,
            suspicious: false,
            notes: "Shutdown socket",
        },
        49 => SyscallInfo {
            name: "bind",
            category: SyscallCategory::Network,
            suspicious: true,
            notes: "Bind socket - backdoor setup",
        },
        50 => SyscallInfo {
            name: "listen",
            category: SyscallCategory::Network,
            suspicious: true,
            notes: "Listen on socket - backdoor indicator",
        },
        51 => SyscallInfo {
            name: "getsockname",
            category: SyscallCategory::Network,
            suspicious: false,
            notes: "Get socket name",
        },
        52 => SyscallInfo {
            name: "getpeername",
            category: SyscallCategory::Network,
            suspicious: false,
            notes: "Get peer name",
        },
        53 => SyscallInfo {
            name: "socketpair",
            category: SyscallCategory::Network,
            suspicious: false,
            notes: "Create socket pair",
        },
        54 => SyscallInfo {
            name: "setsockopt",
            category: SyscallCategory::Network,
            suspicious: false,
            notes: "Set socket options",
        },
        55 => SyscallInfo {
            name: "getsockopt",
            category: SyscallCategory::Network,
            suspicious: false,
            notes: "Get socket options",
        },

        // Process operations - Category: Process
        56 => SyscallInfo {
            name: "clone",
            category: SyscallCategory::Process,
            suspicious: true,
            notes: "Clone process - may create hidden processes",
        },
        57 => SyscallInfo {
            name: "fork",
            category: SyscallCategory::Process,
            suspicious: true,
            notes: "Fork process - process hollowing setup",
        },
        58 => SyscallInfo {
            name: "vfork",
            category: SyscallCategory::Process,
            suspicious: true,
            notes: "Virtual fork - fast process creation",
        },
        59 => SyscallInfo {
            name: "execve",
            category: SyscallCategory::Process,
            suspicious: true,
            notes: "Execute program - payload execution",
        },
        60 => SyscallInfo {
            name: "exit",
            category: SyscallCategory::Process,
            suspicious: false,
            notes: "Exit process",
        },
        61 => SyscallInfo {
            name: "wait4",
            category: SyscallCategory::Process,
            suspicious: false,
            notes: "Wait for process",
        },
        62 => SyscallInfo {
            name: "kill",
            category: SyscallCategory::Process,
            suspicious: true,
            notes: "Send signal - may kill security tools",
        },
        101 => SyscallInfo {
            name: "ptrace",
            category: SyscallCategory::Process,
            suspicious: true,
            notes: "Process trace - anti-debugging or injection",
        },
        102 => SyscallInfo {
            name: "getuid",
            category: SyscallCategory::Process,
            suspicious: false,
            notes: "Get user ID",
        },
        104 => SyscallInfo {
            name: "getgid",
            category: SyscallCategory::Process,
            suspicious: false,
            notes: "Get group ID",
        },
        105 => SyscallInfo {
            name: "setuid",
            category: SyscallCategory::Process,
            suspicious: true,
            notes: "Set user ID - privilege escalation",
        },
        106 => SyscallInfo {
            name: "setgid",
            category: SyscallCategory::Process,
            suspicious: true,
            notes: "Set group ID - privilege escalation",
        },
        107 => SyscallInfo {
            name: "geteuid",
            category: SyscallCategory::Process,
            suspicious: false,
            notes: "Get effective user ID",
        },
        108 => SyscallInfo {
            name: "getegid",
            category: SyscallCategory::Process,
            suspicious: false,
            notes: "Get effective group ID",
        },
        109 => SyscallInfo {
            name: "setpgid",
            category: SyscallCategory::Process,
            suspicious: false,
            notes: "Set process group ID",
        },
        110 => SyscallInfo {
            name: "getppid",
            category: SyscallCategory::Process,
            suspicious: false,
            notes: "Get parent process ID",
        },
        111 => SyscallInfo {
            name: "getpgrp",
            category: SyscallCategory::Process,
            suspicious: false,
            notes: "Get process group",
        },
        112 => SyscallInfo {
            name: "setsid",
            category: SyscallCategory::Process,
            suspicious: true,
            notes: "Create session - daemon/background process",
        },
        157 => SyscallInfo {
            name: "prctl",
            category: SyscallCategory::Process,
            suspicious: true,
            notes: "Process control - may change process name",
        },

        // System operations - Category: System
        7 => SyscallInfo {
            name: "poll",
            category: SyscallCategory::System,
            suspicious: false,
            notes: "Wait for events on file descriptors",
        },
        13 => SyscallInfo {
            name: "rt_sigaction",
            category: SyscallCategory::System,
            suspicious: false,
            notes: "Signal action",
        },
        14 => SyscallInfo {
            name: "rt_sigprocmask",
            category: SyscallCategory::System,
            suspicious: false,
            notes: "Signal mask",
        },
        15 => SyscallInfo {
            name: "rt_sigreturn",
            category: SyscallCategory::System,
            suspicious: false,
            notes: "Return from signal",
        },
        16 => SyscallInfo {
            name: "ioctl",
            category: SyscallCategory::System,
            suspicious: false,
            notes: "I/O control",
        },
        19 => SyscallInfo {
            name: "readv",
            category: SyscallCategory::System,
            suspicious: false,
            notes: "Read vector",
        },
        20 => SyscallInfo {
            name: "writev",
            category: SyscallCategory::System,
            suspicious: false,
            notes: "Write vector",
        },
        23 => SyscallInfo {
            name: "select",
            category: SyscallCategory::System,
            suspicious: false,
            notes: "Select on file descriptors",
        },
        24 => SyscallInfo {
            name: "sched_yield",
            category: SyscallCategory::System,
            suspicious: false,
            notes: "Yield CPU",
        },
        35 => SyscallInfo {
            name: "nanosleep",
            category: SyscallCategory::System,
            suspicious: true,
            notes: "Sleep - sandbox evasion timing",
        },
        36 => SyscallInfo {
            name: "getitimer",
            category: SyscallCategory::System,
            suspicious: false,
            notes: "Get interval timer",
        },
        37 => SyscallInfo {
            name: "alarm",
            category: SyscallCategory::System,
            suspicious: false,
            notes: "Set alarm",
        },
        38 => SyscallInfo {
            name: "setitimer",
            category: SyscallCategory::System,
            suspicious: false,
            notes: "Set interval timer",
        },
        39 => SyscallInfo {
            name: "getpid",
            category: SyscallCategory::System,
            suspicious: false,
            notes: "Get process ID",
        },
        63 => SyscallInfo {
            name: "uname",
            category: SyscallCategory::System,
            suspicious: true,
            notes: "Get system name - fingerprinting/VM detection",
        },
        96 => SyscallInfo {
            name: "gettimeofday",
            category: SyscallCategory::System,
            suspicious: true,
            notes: "Get time - timing attacks/sandbox detection",
        },
        99 => SyscallInfo {
            name: "sysinfo",
            category: SyscallCategory::System,
            suspicious: true,
            notes: "Get system info - sandbox detection",
        },
        158 => SyscallInfo {
            name: "arch_prctl",
            category: SyscallCategory::System,
            suspicious: false,
            notes: "Architecture-specific prctl",
        },
        186 => SyscallInfo {
            name: "gettid",
            category: SyscallCategory::System,
            suspicious: false,
            notes: "Get thread ID",
        },
        218 => SyscallInfo {
            name: "set_tid_address",
            category: SyscallCategory::System,
            suspicious: false,
            notes: "Set TID address",
        },
        231 => SyscallInfo {
            name: "exit_group",
            category: SyscallCategory::System,
            suspicious: false,
            notes: "Exit all threads",
        },
        262 => SyscallInfo {
            name: "newfstatat",
            category: SyscallCategory::File,
            suspicious: false,
            notes: "Get file status relative to directory",
        },
        273 => SyscallInfo {
            name: "set_robust_list",
            category: SyscallCategory::System,
            suspicious: false,
            notes: "Set robust futex list",
        },
        302 => SyscallInfo {
            name: "prlimit64",
            category: SyscallCategory::System,
            suspicious: false,
            notes: "Get/set resource limits",
        },
        318 => SyscallInfo {
            name: "getrandom",
            category: SyscallCategory::System,
            suspicious: false,
            notes: "Get random bytes",
        },
        334 => SyscallInfo {
            name: "rseq",
            category: SyscallCategory::System,
            suspicious: false,
            notes: "Restartable sequences",
        },

        // Default for unknown syscalls
        _ => SyscallInfo {
            name: "unknown",
            category: SyscallCategory::System,
            suspicious: false,
            notes: "Unknown syscall",
        },
    }
}

/// Statistics about traced syscalls
#[derive(Debug, Default, Serialize, Deserialize)]
struct TraceStatistics {
    total_syscalls: usize,
    suspicious_syscalls: usize,
    syscall_counts: HashMap<String, usize>,
    category_counts: HashMap<String, usize>,
    start_time: String,
    end_time: String,
    traced_pid: i32,
}

/// Main syscall tracer
struct SyscallTracer {
    events: Vec<SyscallEvent>,
    stats: TraceStatistics,
    args: Args,
}

impl SyscallTracer {
    fn new(args: Args) -> Self {
        Self {
            events: Vec::new(),
            stats: TraceStatistics::default(),
            args,
        }
    }

    /// Trace a running process by PID
    fn trace_pid(&mut self, pid: Pid) -> Result<()> {
        self.stats.traced_pid = pid.as_raw();
        self.stats.start_time = Local::now().format("%Y-%m-%d %H:%M:%S").to_string();

        println!(
            "{}",
            format!("[*] Attaching to process {}", pid).cyan().bold()
        );

        // Attach to the process
        ptrace::attach(pid).context("Failed to attach to process")?;

        // Wait for the process to stop
        waitpid(pid, None).context("Failed to wait for process")?;

        // Set ptrace options
        ptrace::setoptions(pid, ptrace::Options::PTRACE_O_TRACESYSGOOD)
            .context("Failed to set ptrace options")?;

        self.trace_loop(pid)?;

        self.stats.end_time = Local::now().format("%Y-%m-%d %H:%M:%S").to_string();
        Ok(())
    }

    /// Execute and trace a command
    fn trace_command(&mut self, cmd: &str, cmd_args: &[String]) -> Result<()> {
        self.stats.start_time = Local::now().format("%Y-%m-%d %H:%M:%S").to_string();

        println!(
            "{}",
            format!("[*] Executing and tracing: {} {:?}", cmd, cmd_args)
                .cyan()
                .bold()
        );

        // Fork the process
        match unsafe { fork() }.context("Failed to fork")? {
            ForkResult::Child => {
                // Child process: request to be traced and exec the command
                ptrace::traceme().expect("Failed to request tracing");

                // Execute the command
                let err = Command::new(cmd).args(cmd_args).exec();
                eprintln!("Failed to execute command: {}", err);
                std::process::exit(1);
            }
            ForkResult::Parent { child } => {
                // Parent process: trace the child
                self.stats.traced_pid = child.as_raw();

                // Wait for the child to stop (due to exec)
                waitpid(child, None).context("Failed to wait for child")?;

                // Set ptrace options
                ptrace::setoptions(child, ptrace::Options::PTRACE_O_TRACESYSGOOD)
                    .context("Failed to set ptrace options")?;

                self.trace_loop(child)?;
            }
        }

        self.stats.end_time = Local::now().format("%Y-%m-%d %H:%M:%S").to_string();
        Ok(())
    }

    /// Main tracing loop
    fn trace_loop(&mut self, pid: Pid) -> Result<()> {
        let mut in_syscall = false;
        let mut current_syscall: u64 = 0;
        let mut current_args: Vec<u64> = Vec::new();
        let mut syscall_start = Instant::now();

        loop {
            // Check if we've reached the maximum number of syscalls
            if self.args.max_calls > 0 && self.events.len() >= self.args.max_calls {
                println!(
                    "{}",
                    format!("[*] Reached maximum syscall count: {}", self.args.max_calls).yellow()
                );
                break;
            }

            // Continue until next syscall
            ptrace::syscall(pid, None).context("Failed to continue to syscall")?;

            match waitpid(pid, None) {
                Ok(WaitStatus::Exited(_, code)) => {
                    println!(
                        "{}",
                        format!("[*] Process exited with code: {}", code).green()
                    );
                    break;
                }
                Ok(WaitStatus::Signaled(_, sig, _)) => {
                    println!(
                        "{}",
                        format!("[*] Process killed by signal: {:?}", sig).yellow()
                    );
                    break;
                }
                Ok(WaitStatus::Stopped(_, Signal::SIGTRAP)) | Ok(WaitStatus::PtraceSyscall(..)) => {
                    // Get the registers
                    let regs = ptrace::getregs(pid).context("Failed to get registers")?;

                    if !in_syscall {
                        // Syscall entry
                        in_syscall = true;
                        syscall_start = Instant::now();
                        current_syscall = regs.orig_rax;
                        current_args = vec![regs.rdi, regs.rsi, regs.rdx, regs.r10, regs.r8, regs.r9];
                    } else {
                        // Syscall exit
                        in_syscall = false;
                        let duration = syscall_start.elapsed().as_micros() as u64;

                        let info = get_syscall_info(current_syscall);

                        // Apply category filter
                        let include = match &self.args.filter {
                            Some(SyscallCategory::All) | None => true,
                            Some(cat) => *cat == info.category,
                        };

                        // Apply suspicious filter
                        let include = include && (!self.args.suspicious_only || info.suspicious);

                        if include {
                            let event = SyscallEvent {
                                timestamp: Local::now().format("%H:%M:%S%.3f").to_string(),
                                pid: pid.as_raw(),
                                syscall_num: current_syscall,
                                syscall_name: info.name.to_string(),
                                category: info.category.clone(),
                                args: current_args.clone(),
                                return_value: Some(regs.rax as i64),
                                is_suspicious: info.suspicious,
                                notes: if info.suspicious {
                                    Some(info.notes.to_string())
                                } else {
                                    None
                                },
                                duration_us: duration,
                            };

                            self.print_event(&event);
                            self.update_stats(&event);
                            self.events.push(event);
                        }
                    }
                }
                Ok(WaitStatus::Stopped(_, sig)) => {
                    // Forward the signal
                    ptrace::syscall(pid, Some(sig)).context("Failed to forward signal")?;
                }
                Ok(status) => {
                    if self.args.verbose {
                        eprintln!("[DEBUG] Unexpected wait status: {:?}", status);
                    }
                }
                Err(e) => {
                    eprintln!("[!] Wait error: {}", e);
                    break;
                }
            }
        }

        Ok(())
    }

    /// Print a syscall event
    fn print_event(&self, event: &SyscallEvent) {
        let category_color = match event.category {
            SyscallCategory::File => "blue",
            SyscallCategory::Network => "magenta",
            SyscallCategory::Process => "yellow",
            SyscallCategory::Memory => "cyan",
            SyscallCategory::System => "white",
            SyscallCategory::All => "white",
        };

        let syscall_display = if event.is_suspicious {
            format!("{} [!]", event.syscall_name).red().bold()
        } else {
            event.syscall_name.color(category_color).normal()
        };

        let args_str: Vec<String> = event.args.iter().map(|a| format!("0x{:x}", a)).collect();

        let ret_str = match event.return_value {
            Some(v) if v < 0 => format!("{}", v).red().to_string(),
            Some(v) => format!("{}", v).green().to_string(),
            None => "?".to_string(),
        };

        println!(
            "{} [{}] {}({}) = {} ({}us)",
            event.timestamp.dimmed(),
            format!("{:?}", event.category).color(category_color),
            syscall_display,
            args_str.join(", ").dimmed(),
            ret_str,
            event.duration_us
        );

        if event.is_suspicious {
            if let Some(notes) = &event.notes {
                println!("    {} {}", "->".red(), notes.yellow());
            }
        }
    }

    /// Update statistics
    fn update_stats(&mut self, event: &SyscallEvent) {
        self.stats.total_syscalls += 1;
        if event.is_suspicious {
            self.stats.suspicious_syscalls += 1;
        }

        *self
            .stats
            .syscall_counts
            .entry(event.syscall_name.clone())
            .or_insert(0) += 1;
        *self
            .stats
            .category_counts
            .entry(format!("{:?}", event.category))
            .or_insert(0) += 1;
    }

    /// Print summary statistics
    fn print_summary(&self) {
        println!("\n{}", "=".repeat(60).cyan());
        println!("{}", "TRACE SUMMARY".cyan().bold());
        println!("{}", "=".repeat(60).cyan());

        println!(
            "Total syscalls traced: {}",
            self.stats.total_syscalls.to_string().green()
        );
        println!(
            "Suspicious syscalls:   {}",
            if self.stats.suspicious_syscalls > 0 {
                self.stats.suspicious_syscalls.to_string().red().bold()
            } else {
                self.stats.suspicious_syscalls.to_string().green().normal()
            }
        );
        println!("Traced PID:            {}", self.stats.traced_pid);
        println!("Start time:            {}", self.stats.start_time);
        println!("End time:              {}", self.stats.end_time);

        if !self.stats.category_counts.is_empty() {
            println!("\n{}", "Syscalls by Category:".bold());
            for (cat, count) in &self.stats.category_counts {
                println!("  {}: {}", cat, count);
            }
        }

        if !self.stats.syscall_counts.is_empty() && self.args.verbose {
            println!("\n{}", "Top 10 Syscalls:".bold());
            let mut sorted: Vec<_> = self.stats.syscall_counts.iter().collect();
            sorted.sort_by(|a, b| b.1.cmp(a.1));
            for (name, count) in sorted.iter().take(10) {
                println!("  {}: {}", name, count);
            }
        }
    }

    /// Save results to file
    fn save_results(&self, path: &str) -> Result<()> {
        let file = File::create(path).context("Failed to create output file")?;
        let mut writer = BufWriter::new(file);

        match self.args.format {
            OutputFormat::Json => {
                let output = serde_json::json!({
                    "events": self.events,
                    "statistics": self.stats
                });
                serde_json::to_writer_pretty(&mut writer, &output)?;
            }
            OutputFormat::Csv => {
                writeln!(
                    writer,
                    "timestamp,pid,syscall_num,syscall_name,category,args,return_value,is_suspicious,notes,duration_us"
                )?;
                for event in &self.events {
                    writeln!(
                        writer,
                        "{},{},{},{},{:?},{:?},{:?},{},{:?},{}",
                        event.timestamp,
                        event.pid,
                        event.syscall_num,
                        event.syscall_name,
                        event.category,
                        event.args,
                        event.return_value,
                        event.is_suspicious,
                        event.notes,
                        event.duration_us
                    )?;
                }
            }
            OutputFormat::Text => {
                for event in &self.events {
                    writeln!(
                        writer,
                        "{} [{}] {}({:?}) = {:?} ({}us){}",
                        event.timestamp,
                        format!("{:?}", event.category),
                        event.syscall_name,
                        event.args,
                        event.return_value,
                        event.duration_us,
                        if event.is_suspicious {
                            format!(" [SUSPICIOUS: {}]", event.notes.as_deref().unwrap_or(""))
                        } else {
                            String::new()
                        }
                    )?;
                }
            }
        }

        println!(
            "{}",
            format!("[*] Results saved to: {}", path).green().bold()
        );
        Ok(())
    }
}

fn main() -> Result<()> {
    let args = Args::parse();

    println!("{}", "=".repeat(60).cyan());
    println!(
        "{}",
        "  SYSCALL TRACER - Malware Dynamic Analysis Tool"
            .cyan()
            .bold()
    );
    println!("{}", "  For DEFENSIVE security research only".yellow());
    println!("{}", "=".repeat(60).cyan());
    println!();

    // Check for root privileges (required for ptrace on other processes)
    if args.pid.is_some() && nix::unistd::geteuid().as_raw() != 0 {
        eprintln!(
            "{}",
            "[!] Warning: Attaching to other processes may require root privileges".yellow()
        );
    }

    let mut tracer = SyscallTracer::new(args.clone());

    if let Some(pid) = args.pid {
        // Attach to existing process
        tracer.trace_pid(Pid::from_raw(pid))?;
    } else if let Some(cmd) = args.command {
        // Execute and trace command
        tracer.trace_command(&cmd, &args.args)?;
    } else {
        // Demo mode - trace 'ls' command
        println!("{}", "[*] Demo mode: tracing 'ls -la' command".yellow());
        tracer.trace_command("ls", &["-la".to_string()])?;
    }

    // Print summary
    tracer.print_summary();

    // Save results if output file specified
    if let Some(output_path) = &args.output {
        tracer.save_results(output_path)?;
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_syscall_info() {
        let info = get_syscall_info(0);
        assert_eq!(info.name, "read");
        assert_eq!(info.category, SyscallCategory::File);

        let info = get_syscall_info(41);
        assert_eq!(info.name, "socket");
        assert_eq!(info.category, SyscallCategory::Network);
        assert!(info.suspicious);
    }

    #[test]
    fn test_unknown_syscall() {
        let info = get_syscall_info(9999);
        assert_eq!(info.name, "unknown");
    }
}
