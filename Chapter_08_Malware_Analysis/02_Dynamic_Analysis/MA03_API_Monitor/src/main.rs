//! # API Monitor for Malware Analysis
//!
//! This tool monitors API calls made by processes to understand their behavior.
//! It focuses on library function calls and system APIs that malware commonly uses.
//!
//! ## Malware Analysis Concepts
//!
//! **API Monitoring**: Malware interacts with the system through various APIs:
//! - C library functions (libc): malloc, free, memcpy, strcpy
//! - Network APIs: socket, connect, send, recv
//! - File APIs: fopen, fread, fwrite, fclose
//! - Process APIs: fork, exec, system, popen
//! - Cryptography APIs: encryption, hashing functions
//!
//! **Common Malware API Patterns**:
//! - Process injection: ptrace, mmap, mprotect
//! - Anti-debugging: IsDebuggerPresent (Windows), ptrace (Linux)
//! - Persistence: Registry (Windows), cron/systemd (Linux)
//! - Network communication: socket, connect to C2 servers
//! - File dropping: creating and writing executable files
//!
//! ## Implementation Approach
//!
//! This monitor uses /proc filesystem to gather information about:
//! - Loaded libraries and their symbols
//! - Memory mappings
//! - File descriptors
//! - Network connections
//!
//! ## DEFENSIVE USE ONLY
//! This tool is designed for analyzing potentially malicious samples in
//! controlled environments to understand their behavior.

use anyhow::{Context, Result};
use chrono::Local;
use clap::{Parser, ValueEnum};
use colored::*;
use goblin::elf::Elf;
use regex::Regex;
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet};
use std::fs::{self, File};
use std::io::{BufRead, BufReader, BufWriter, Write};
use std::path::{Path, PathBuf};
use std::time::{Duration, Instant};

/// API Monitor - Dynamic Malware Analysis Tool
///
/// Monitors API calls and library usage by processes to understand behavior.
/// Essential for analyzing suspicious binaries in controlled environments.
#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    /// Target process ID to monitor
    #[arg(short, long)]
    pid: Option<i32>,

    /// Monitor all processes matching this name
    #[arg(short, long)]
    name: Option<String>,

    /// Output format
    #[arg(short, long, value_enum, default_value = "text")]
    format: OutputFormat,

    /// Output file (stdout if not specified)
    #[arg(short = 'o', long)]
    output: Option<String>,

    /// Filter by API category
    #[arg(short = 'c', long)]
    category: Option<ApiCategory>,

    /// Monitor interval in milliseconds
    #[arg(short = 'i', long, default_value = "1000")]
    interval: u64,

    /// Duration to monitor in seconds (0 = continuous)
    #[arg(short = 'd', long, default_value = "30")]
    duration: u64,

    /// Show only suspicious API patterns
    #[arg(long)]
    suspicious_only: bool,

    /// Analyze loaded libraries for suspicious imports
    #[arg(long)]
    analyze_imports: bool,

    /// Verbose output
    #[arg(short, long)]
    verbose: bool,
}

/// Output format for API traces
#[derive(Debug, Clone, ValueEnum)]
enum OutputFormat {
    Text,
    Json,
    Csv,
}

/// API categories for filtering
#[derive(Debug, Clone, ValueEnum, PartialEq, Eq, Serialize, Deserialize, Hash)]
enum ApiCategory {
    File,
    Network,
    Process,
    Memory,
    Crypto,
    System,
    AntiDebug,
    All,
}

/// Represents a monitored API/function
#[derive(Debug, Clone, Serialize, Deserialize)]
struct ApiInfo {
    /// Function name
    name: String,
    /// Library/module containing the function
    library: String,
    /// Category of the API
    category: ApiCategory,
    /// Whether this API is suspicious in certain contexts
    suspicious: bool,
    /// Description of what the API does
    description: String,
    /// Malware context (why malware might use this)
    malware_context: Option<String>,
}

/// Represents a process being monitored
#[derive(Debug, Clone, Serialize, Deserialize)]
struct ProcessInfo {
    /// Process ID
    pid: i32,
    /// Process name
    name: String,
    /// Command line
    cmdline: String,
    /// User ID
    uid: u32,
    /// Parent PID
    ppid: i32,
    /// Executable path
    exe_path: String,
    /// Current working directory
    cwd: String,
    /// Start time
    start_time: String,
}

/// Represents a loaded library
#[derive(Debug, Clone, Serialize, Deserialize)]
struct LoadedLibrary {
    /// Library path
    path: String,
    /// Base address
    base_addr: u64,
    /// Size
    size: u64,
    /// Permissions
    permissions: String,
    /// Imported symbols (if analyzed)
    imports: Vec<String>,
    /// Suspicious imports found
    suspicious_imports: Vec<String>,
}

/// Represents a network connection
#[derive(Debug, Clone, Serialize, Deserialize)]
struct NetworkConnection {
    /// Protocol (tcp, udp, etc.)
    protocol: String,
    /// Local address
    local_addr: String,
    /// Remote address
    remote_addr: String,
    /// State
    state: String,
    /// Inode (for linking to process)
    inode: u64,
}

/// Represents a file descriptor
#[derive(Debug, Clone, Serialize, Deserialize)]
struct FileDescriptor {
    /// FD number
    fd: i32,
    /// Type (file, socket, pipe, etc.)
    fd_type: String,
    /// Path or description
    path: String,
    /// Flags
    flags: String,
}

/// Snapshot of process state
#[derive(Debug, Clone, Serialize, Deserialize)]
struct ProcessSnapshot {
    /// Timestamp
    timestamp: String,
    /// Process info
    process: ProcessInfo,
    /// Loaded libraries
    libraries: Vec<LoadedLibrary>,
    /// Open file descriptors
    file_descriptors: Vec<FileDescriptor>,
    /// Network connections
    network_connections: Vec<NetworkConnection>,
    /// Memory usage
    memory_usage: MemoryUsage,
    /// Detected suspicious activities
    suspicious_activities: Vec<SuspiciousActivity>,
}

/// Memory usage information
#[derive(Debug, Clone, Serialize, Deserialize)]
struct MemoryUsage {
    /// Virtual memory size
    vsize: u64,
    /// Resident set size
    rss: u64,
    /// Shared memory
    shared: u64,
    /// Data segment size
    data: u64,
}

/// Represents a detected suspicious activity
#[derive(Debug, Clone, Serialize, Deserialize)]
struct SuspiciousActivity {
    /// Activity type
    activity_type: String,
    /// Severity (low, medium, high, critical)
    severity: String,
    /// Description
    description: String,
    /// Evidence
    evidence: String,
    /// Timestamp
    timestamp: String,
}

/// Known suspicious API patterns
struct SuspiciousApiPattern {
    name: &'static str,
    pattern: &'static str,
    category: ApiCategory,
    severity: &'static str,
    description: &'static str,
}

/// Get list of known suspicious API patterns
fn get_suspicious_patterns() -> Vec<SuspiciousApiPattern> {
    vec![
        // Anti-debugging patterns
        SuspiciousApiPattern {
            name: "ptrace_self",
            pattern: "ptrace",
            category: ApiCategory::AntiDebug,
            severity: "high",
            description: "Anti-debugging technique - process may detect debuggers",
        },
        SuspiciousApiPattern {
            name: "timing_check",
            pattern: "clock_gettime|gettimeofday|rdtsc",
            category: ApiCategory::AntiDebug,
            severity: "medium",
            description: "Timing check - may detect sandbox/VM environment",
        },
        // Process injection patterns
        SuspiciousApiPattern {
            name: "memory_manipulation",
            pattern: "mmap|mprotect|munmap",
            category: ApiCategory::Memory,
            severity: "medium",
            description: "Memory manipulation - may indicate code injection",
        },
        SuspiciousApiPattern {
            name: "process_spawn",
            pattern: "fork|vfork|clone|execve|system|popen",
            category: ApiCategory::Process,
            severity: "high",
            description: "Process creation - may spawn malicious child processes",
        },
        // Network patterns
        SuspiciousApiPattern {
            name: "network_communication",
            pattern: "socket|connect|bind|listen|accept|send|recv",
            category: ApiCategory::Network,
            severity: "high",
            description: "Network communication - may contact C2 server",
        },
        SuspiciousApiPattern {
            name: "dns_resolution",
            pattern: "getaddrinfo|gethostbyname|res_query",
            category: ApiCategory::Network,
            severity: "medium",
            description: "DNS resolution - may resolve C2 domain",
        },
        // File operations
        SuspiciousApiPattern {
            name: "file_creation",
            pattern: "creat|open.*O_CREAT|fopen.*w",
            category: ApiCategory::File,
            severity: "medium",
            description: "File creation - may drop payloads",
        },
        SuspiciousApiPattern {
            name: "file_deletion",
            pattern: "unlink|remove|rmdir",
            category: ApiCategory::File,
            severity: "high",
            description: "File deletion - may remove evidence",
        },
        // Cryptography
        SuspiciousApiPattern {
            name: "encryption",
            pattern: "EVP_Encrypt|AES_|DES_|RC4|crypt",
            category: ApiCategory::Crypto,
            severity: "medium",
            description: "Encryption - may encrypt data for exfiltration or ransomware",
        },
        SuspiciousApiPattern {
            name: "hashing",
            pattern: "MD5|SHA1|SHA256|SHA512",
            category: ApiCategory::Crypto,
            severity: "low",
            description: "Hashing - may hash files or verify integrity",
        },
        // Privilege escalation
        SuspiciousApiPattern {
            name: "privilege_change",
            pattern: "setuid|setgid|seteuid|setreuid|setresuid",
            category: ApiCategory::Process,
            severity: "critical",
            description: "Privilege change - may attempt privilege escalation",
        },
        // Environment reconnaissance
        SuspiciousApiPattern {
            name: "environment_recon",
            pattern: "uname|sysinfo|getenv",
            category: ApiCategory::System,
            severity: "low",
            description: "Environment reconnaissance - gathering system information",
        },
    ]
}

/// Main API monitor
struct ApiMonitor {
    args: Args,
    snapshots: Vec<ProcessSnapshot>,
    suspicious_patterns: Vec<SuspiciousApiPattern>,
    known_apis: HashMap<String, ApiInfo>,
}

impl ApiMonitor {
    fn new(args: Args) -> Self {
        let mut monitor = Self {
            args,
            snapshots: Vec::new(),
            suspicious_patterns: get_suspicious_patterns(),
            known_apis: HashMap::new(),
        };
        monitor.load_known_apis();
        monitor
    }

    /// Load known API definitions
    fn load_known_apis(&mut self) {
        // File APIs
        self.add_api("open", "libc", ApiCategory::File, false,
            "Open a file", None);
        self.add_api("openat", "libc", ApiCategory::File, false,
            "Open file relative to directory", None);
        self.add_api("creat", "libc", ApiCategory::File, true,
            "Create a new file", Some("May drop malware payload"));
        self.add_api("read", "libc", ApiCategory::File, false,
            "Read from file descriptor", None);
        self.add_api("write", "libc", ApiCategory::File, false,
            "Write to file descriptor", None);
        self.add_api("close", "libc", ApiCategory::File, false,
            "Close file descriptor", None);
        self.add_api("unlink", "libc", ApiCategory::File, true,
            "Delete a file", Some("May delete evidence or self-destruct"));
        self.add_api("rename", "libc", ApiCategory::File, true,
            "Rename a file", Some("May hide malware files"));
        self.add_api("chmod", "libc", ApiCategory::File, true,
            "Change file permissions", Some("May make dropped file executable"));
        self.add_api("chown", "libc", ApiCategory::File, true,
            "Change file owner", Some("May change ownership for persistence"));

        // Network APIs
        self.add_api("socket", "libc", ApiCategory::Network, true,
            "Create network socket", Some("Setting up network communication"));
        self.add_api("connect", "libc", ApiCategory::Network, true,
            "Connect to remote host", Some("C2 communication"));
        self.add_api("bind", "libc", ApiCategory::Network, true,
            "Bind socket to address", Some("Setting up backdoor listener"));
        self.add_api("listen", "libc", ApiCategory::Network, true,
            "Listen for connections", Some("Backdoor setup"));
        self.add_api("accept", "libc", ApiCategory::Network, true,
            "Accept connection", Some("Accepting backdoor connection"));
        self.add_api("send", "libc", ApiCategory::Network, true,
            "Send data", Some("Data exfiltration"));
        self.add_api("recv", "libc", ApiCategory::Network, true,
            "Receive data", Some("Receiving C2 commands"));
        self.add_api("sendto", "libc", ApiCategory::Network, true,
            "Send to address", Some("UDP data exfiltration"));
        self.add_api("recvfrom", "libc", ApiCategory::Network, true,
            "Receive from address", Some("UDP C2 communication"));
        self.add_api("getaddrinfo", "libc", ApiCategory::Network, true,
            "DNS resolution", Some("Resolving C2 domain"));
        self.add_api("gethostbyname", "libc", ApiCategory::Network, true,
            "Legacy DNS resolution", Some("Resolving C2 domain"));

        // Process APIs
        self.add_api("fork", "libc", ApiCategory::Process, true,
            "Create child process", Some("Spawning hidden processes"));
        self.add_api("vfork", "libc", ApiCategory::Process, true,
            "Fast fork", Some("Spawning hidden processes"));
        self.add_api("clone", "libc", ApiCategory::Process, true,
            "Create thread or process", Some("Creating hidden threads"));
        self.add_api("execve", "libc", ApiCategory::Process, true,
            "Execute program", Some("Executing payload"));
        self.add_api("system", "libc", ApiCategory::Process, true,
            "Execute shell command", Some("Running malicious commands"));
        self.add_api("popen", "libc", ApiCategory::Process, true,
            "Open process pipe", Some("Running commands with output"));
        self.add_api("kill", "libc", ApiCategory::Process, true,
            "Send signal to process", Some("Killing security processes"));
        self.add_api("ptrace", "libc", ApiCategory::Process, true,
            "Process trace", Some("Anti-debugging or process injection"));

        // Memory APIs
        self.add_api("mmap", "libc", ApiCategory::Memory, true,
            "Map memory", Some("Allocating executable memory for code injection"));
        self.add_api("mprotect", "libc", ApiCategory::Memory, true,
            "Change memory protection", Some("Making memory executable for shellcode"));
        self.add_api("munmap", "libc", ApiCategory::Memory, false,
            "Unmap memory", None);
        self.add_api("malloc", "libc", ApiCategory::Memory, false,
            "Allocate memory", None);
        self.add_api("calloc", "libc", ApiCategory::Memory, false,
            "Allocate zeroed memory", None);
        self.add_api("realloc", "libc", ApiCategory::Memory, false,
            "Reallocate memory", None);
        self.add_api("free", "libc", ApiCategory::Memory, false,
            "Free memory", None);
        self.add_api("memcpy", "libc", ApiCategory::Memory, false,
            "Copy memory", None);
        self.add_api("memmove", "libc", ApiCategory::Memory, false,
            "Move memory", None);

        // Crypto APIs
        self.add_api("EVP_EncryptInit", "libcrypto", ApiCategory::Crypto, true,
            "Initialize encryption", Some("Encrypting data - possible ransomware"));
        self.add_api("EVP_DecryptInit", "libcrypto", ApiCategory::Crypto, true,
            "Initialize decryption", Some("Decrypting embedded payload"));
        self.add_api("AES_encrypt", "libcrypto", ApiCategory::Crypto, true,
            "AES encryption", Some("Strong encryption - possible ransomware"));
        self.add_api("RSA_public_encrypt", "libcrypto", ApiCategory::Crypto, true,
            "RSA encryption", Some("Asymmetric encryption - ransomware key exchange"));
        self.add_api("MD5", "libcrypto", ApiCategory::Crypto, false,
            "MD5 hash", None);
        self.add_api("SHA256", "libcrypto", ApiCategory::Crypto, false,
            "SHA256 hash", None);

        // Anti-debugging APIs
        self.add_api("getppid", "libc", ApiCategory::AntiDebug, true,
            "Get parent PID", Some("Checking for debugger attachment"));
        self.add_api("prctl", "libc", ApiCategory::AntiDebug, true,
            "Process control", Some("May set process name or dumpable flag"));

        // System APIs
        self.add_api("uname", "libc", ApiCategory::System, true,
            "Get system information", Some("Environment fingerprinting"));
        self.add_api("sysinfo", "libc", ApiCategory::System, true,
            "Get system statistics", Some("Detecting sandbox environment"));
        self.add_api("getenv", "libc", ApiCategory::System, false,
            "Get environment variable", None);
        self.add_api("setenv", "libc", ApiCategory::System, false,
            "Set environment variable", None);
        self.add_api("gettimeofday", "libc", ApiCategory::System, true,
            "Get time of day", Some("Timing-based sandbox detection"));
        self.add_api("clock_gettime", "libc", ApiCategory::System, true,
            "Get clock time", Some("High-resolution timing for evasion"));
        self.add_api("nanosleep", "libc", ApiCategory::System, true,
            "High-precision sleep", Some("Sandbox evasion via delayed execution"));
        self.add_api("sleep", "libc", ApiCategory::System, true,
            "Sleep", Some("Sandbox evasion via delayed execution"));
    }

    fn add_api(&mut self, name: &str, library: &str, category: ApiCategory,
               suspicious: bool, description: &str, malware_context: Option<&str>) {
        self.known_apis.insert(name.to_string(), ApiInfo {
            name: name.to_string(),
            library: library.to_string(),
            category,
            suspicious,
            description: description.to_string(),
            malware_context: malware_context.map(String::from),
        });
    }

    /// Get process information from /proc
    fn get_process_info(&self, pid: i32) -> Result<ProcessInfo> {
        let proc_path = format!("/proc/{}", pid);

        // Read comm (process name)
        let name = fs::read_to_string(format!("{}/comm", proc_path))
            .unwrap_or_else(|_| "unknown".to_string())
            .trim()
            .to_string();

        // Read cmdline
        let cmdline = fs::read_to_string(format!("{}/cmdline", proc_path))
            .unwrap_or_default()
            .replace('\0', " ")
            .trim()
            .to_string();

        // Read status for UID and PPID
        let status = fs::read_to_string(format!("{}/status", proc_path))
            .unwrap_or_default();

        let mut uid = 0u32;
        let mut ppid = 0i32;

        for line in status.lines() {
            if line.starts_with("Uid:") {
                if let Some(val) = line.split_whitespace().nth(1) {
                    uid = val.parse().unwrap_or(0);
                }
            } else if line.starts_with("PPid:") {
                if let Some(val) = line.split_whitespace().nth(1) {
                    ppid = val.parse().unwrap_or(0);
                }
            }
        }

        // Read exe path
        let exe_path = fs::read_link(format!("{}/exe", proc_path))
            .map(|p| p.display().to_string())
            .unwrap_or_else(|_| "unknown".to_string());

        // Read cwd
        let cwd = fs::read_link(format!("{}/cwd", proc_path))
            .map(|p| p.display().to_string())
            .unwrap_or_else(|_| "unknown".to_string());

        Ok(ProcessInfo {
            pid,
            name,
            cmdline,
            uid,
            ppid,
            exe_path,
            cwd,
            start_time: Local::now().format("%Y-%m-%d %H:%M:%S").to_string(),
        })
    }

    /// Get loaded libraries from /proc/PID/maps
    fn get_loaded_libraries(&self, pid: i32) -> Result<Vec<LoadedLibrary>> {
        let maps_path = format!("/proc/{}/maps", pid);
        let file = File::open(&maps_path).context("Failed to open maps file")?;
        let reader = BufReader::new(file);

        let mut libraries: HashMap<String, LoadedLibrary> = HashMap::new();

        for line in reader.lines() {
            let line = line?;
            let parts: Vec<&str> = line.split_whitespace().collect();

            if parts.len() < 6 {
                continue;
            }

            let path = parts.get(5).map(|s| s.to_string()).unwrap_or_default();

            // Only track actual library files
            if !path.ends_with(".so") && !path.contains(".so.") && path != "[heap]" && path != "[stack]" {
                continue;
            }

            // Parse address range
            let addr_range: Vec<&str> = parts[0].split('-').collect();
            if addr_range.len() != 2 {
                continue;
            }

            let start_addr = u64::from_str_radix(addr_range[0], 16).unwrap_or(0);
            let end_addr = u64::from_str_radix(addr_range[1], 16).unwrap_or(0);
            let perms = parts[1].to_string();

            libraries.entry(path.clone())
                .and_modify(|lib| {
                    let new_size = end_addr - lib.base_addr;
                    if new_size > lib.size {
                        lib.size = new_size;
                    }
                    if !lib.permissions.contains(&perms) {
                        lib.permissions.push_str(&format!(",{}", perms));
                    }
                })
                .or_insert(LoadedLibrary {
                    path,
                    base_addr: start_addr,
                    size: end_addr - start_addr,
                    permissions: perms,
                    imports: Vec::new(),
                    suspicious_imports: Vec::new(),
                });
        }

        let mut result: Vec<LoadedLibrary> = libraries.into_values().collect();

        // Analyze imports if requested
        if self.args.analyze_imports {
            for lib in &mut result {
                if let Ok(imports) = self.analyze_library_imports(&lib.path) {
                    lib.imports = imports.clone();
                    lib.suspicious_imports = imports.iter()
                        .filter(|imp| self.known_apis.get(*imp).map(|a| a.suspicious).unwrap_or(false))
                        .cloned()
                        .collect();
                }
            }
        }

        Ok(result)
    }

    /// Analyze library imports using goblin
    fn analyze_library_imports(&self, path: &str) -> Result<Vec<String>> {
        if !Path::new(path).exists() {
            return Ok(Vec::new());
        }

        let data = fs::read(path)?;
        let elf = Elf::parse(&data)?;

        let mut imports = Vec::new();

        // Get dynamic symbols (imports)
        for sym in &elf.dynsyms {
            if let Some(name) = elf.dynstrtab.get_at(sym.st_name) {
                if !name.is_empty() && sym.st_shndx == 0 {
                    imports.push(name.to_string());
                }
            }
        }

        Ok(imports)
    }

    /// Get open file descriptors from /proc/PID/fd
    fn get_file_descriptors(&self, pid: i32) -> Result<Vec<FileDescriptor>> {
        let fd_path = format!("/proc/{}/fd", pid);
        let mut fds = Vec::new();

        if let Ok(entries) = fs::read_dir(&fd_path) {
            for entry in entries.filter_map(|e| e.ok()) {
                let fd_num: i32 = entry.file_name().to_string_lossy().parse().unwrap_or(-1);
                if fd_num < 0 {
                    continue;
                }

                let link = fs::read_link(entry.path())
                    .map(|p| p.display().to_string())
                    .unwrap_or_else(|_| "unknown".to_string());

                let fd_type = if link.starts_with("socket:") {
                    "socket"
                } else if link.starts_with("pipe:") {
                    "pipe"
                } else if link.starts_with("anon_inode:") {
                    "anon_inode"
                } else if link.starts_with("/dev/") {
                    "device"
                } else {
                    "file"
                }.to_string();

                // Read fdinfo for flags
                let flags = fs::read_to_string(format!("/proc/{}/fdinfo/{}", pid, fd_num))
                    .ok()
                    .and_then(|content| {
                        content.lines()
                            .find(|l| l.starts_with("flags:"))
                            .map(|l| l.replace("flags:", "").trim().to_string())
                    })
                    .unwrap_or_else(|| "unknown".to_string());

                fds.push(FileDescriptor {
                    fd: fd_num,
                    fd_type,
                    path: link,
                    flags,
                });
            }
        }

        Ok(fds)
    }

    /// Get network connections from /proc/net
    fn get_network_connections(&self, pid: i32) -> Result<Vec<NetworkConnection>> {
        let mut connections = Vec::new();

        // Get process socket inodes
        let fd_path = format!("/proc/{}/fd", pid);
        let mut socket_inodes: HashSet<u64> = HashSet::new();

        if let Ok(entries) = fs::read_dir(&fd_path) {
            for entry in entries.filter_map(|e| e.ok()) {
                if let Ok(link) = fs::read_link(entry.path()) {
                    let link_str = link.to_string_lossy();
                    if link_str.starts_with("socket:[") {
                        if let Some(inode_str) = link_str
                            .strip_prefix("socket:[")
                            .and_then(|s| s.strip_suffix(']'))
                        {
                            if let Ok(inode) = inode_str.parse::<u64>() {
                                socket_inodes.insert(inode);
                            }
                        }
                    }
                }
            }
        }

        // Parse /proc/net/tcp and /proc/net/udp
        for (proto, path) in &[("tcp", "/proc/net/tcp"), ("tcp6", "/proc/net/tcp6"),
                               ("udp", "/proc/net/udp"), ("udp6", "/proc/net/udp6")] {
            if let Ok(file) = File::open(path) {
                let reader = BufReader::new(file);
                for (i, line) in reader.lines().enumerate() {
                    if i == 0 { continue; } // Skip header

                    if let Ok(line) = line {
                        if let Some(conn) = self.parse_net_line(&line, proto, &socket_inodes) {
                            connections.push(conn);
                        }
                    }
                }
            }
        }

        Ok(connections)
    }

    /// Parse a line from /proc/net/tcp or /proc/net/udp
    fn parse_net_line(&self, line: &str, proto: &str, socket_inodes: &HashSet<u64>) -> Option<NetworkConnection> {
        let parts: Vec<&str> = line.split_whitespace().collect();
        if parts.len() < 10 {
            return None;
        }

        let inode: u64 = parts.get(9)?.parse().ok()?;

        // Only include sockets belonging to this process
        if !socket_inodes.contains(&inode) {
            return None;
        }

        let local = self.parse_hex_address(parts.get(1)?)?;
        let remote = self.parse_hex_address(parts.get(2)?)?;
        let state = self.parse_tcp_state(parts.get(3)?);

        Some(NetworkConnection {
            protocol: proto.to_string(),
            local_addr: local,
            remote_addr: remote,
            state,
            inode,
        })
    }

    /// Parse hex IP:port format
    fn parse_hex_address(&self, hex_addr: &str) -> Option<String> {
        let parts: Vec<&str> = hex_addr.split(':').collect();
        if parts.len() != 2 {
            return None;
        }

        let ip_hex = parts[0];
        let port = u16::from_str_radix(parts[1], 16).ok()?;

        if ip_hex.len() == 8 {
            // IPv4
            let ip = u32::from_str_radix(ip_hex, 16).ok()?;
            let ip_str = format!(
                "{}.{}.{}.{}",
                ip & 0xFF,
                (ip >> 8) & 0xFF,
                (ip >> 16) & 0xFF,
                (ip >> 24) & 0xFF
            );
            Some(format!("{}:{}", ip_str, port))
        } else {
            // IPv6 (simplified)
            Some(format!("[{}]:{}", ip_hex, port))
        }
    }

    /// Parse TCP state code
    fn parse_tcp_state(&self, state: &str) -> String {
        match state {
            "01" => "ESTABLISHED",
            "02" => "SYN_SENT",
            "03" => "SYN_RECV",
            "04" => "FIN_WAIT1",
            "05" => "FIN_WAIT2",
            "06" => "TIME_WAIT",
            "07" => "CLOSE",
            "08" => "CLOSE_WAIT",
            "09" => "LAST_ACK",
            "0A" => "LISTEN",
            "0B" => "CLOSING",
            _ => "UNKNOWN",
        }.to_string()
    }

    /// Get memory usage from /proc/PID/statm
    fn get_memory_usage(&self, pid: i32) -> Result<MemoryUsage> {
        let statm_path = format!("/proc/{}/statm", pid);
        let content = fs::read_to_string(&statm_path)?;
        let parts: Vec<u64> = content
            .split_whitespace()
            .filter_map(|s| s.parse().ok())
            .collect();

        let page_size = 4096u64; // Standard page size

        Ok(MemoryUsage {
            vsize: parts.get(0).copied().unwrap_or(0) * page_size,
            rss: parts.get(1).copied().unwrap_or(0) * page_size,
            shared: parts.get(2).copied().unwrap_or(0) * page_size,
            data: parts.get(5).copied().unwrap_or(0) * page_size,
        })
    }

    /// Detect suspicious activities in the current snapshot
    fn detect_suspicious_activities(&self, snapshot: &ProcessSnapshot) -> Vec<SuspiciousActivity> {
        let mut activities = Vec::new();
        let timestamp = Local::now().format("%H:%M:%S%.3f").to_string();

        // Check for suspicious library imports
        for lib in &snapshot.libraries {
            if !lib.suspicious_imports.is_empty() {
                activities.push(SuspiciousActivity {
                    activity_type: "suspicious_imports".to_string(),
                    severity: "medium".to_string(),
                    description: format!("Library {} has suspicious imports", lib.path),
                    evidence: lib.suspicious_imports.join(", "),
                    timestamp: timestamp.clone(),
                });
            }
        }

        // Check for network connections to unusual ports
        for conn in &snapshot.network_connections {
            if conn.state == "ESTABLISHED" && !conn.remote_addr.contains("127.0.0.1") {
                // Check for common C2 ports
                let remote_port = conn.remote_addr
                    .rsplit(':')
                    .next()
                    .and_then(|p| p.parse::<u16>().ok())
                    .unwrap_or(0);

                let suspicious_ports = [4444, 5555, 6666, 7777, 8888, 9999, 1337, 31337, 12345];
                if suspicious_ports.contains(&remote_port) {
                    activities.push(SuspiciousActivity {
                        activity_type: "suspicious_network".to_string(),
                        severity: "high".to_string(),
                        description: "Connection to suspicious port".to_string(),
                        evidence: format!("{} -> {}", conn.local_addr, conn.remote_addr),
                        timestamp: timestamp.clone(),
                    });
                }
            }

            // Check for listening sockets (potential backdoor)
            if conn.state == "LISTEN" {
                activities.push(SuspiciousActivity {
                    activity_type: "listening_socket".to_string(),
                    severity: "medium".to_string(),
                    description: "Process has listening socket (potential backdoor)".to_string(),
                    evidence: format!("Listening on {}", conn.local_addr),
                    timestamp: timestamp.clone(),
                });
            }
        }

        // Check for suspicious file descriptors
        for fd in &snapshot.file_descriptors {
            // Check for access to sensitive files
            let sensitive_paths = [
                "/etc/passwd", "/etc/shadow", "/etc/sudoers",
                "/root/.ssh", "/.bash_history", "/proc/",
            ];

            for sensitive in &sensitive_paths {
                if fd.path.contains(sensitive) {
                    activities.push(SuspiciousActivity {
                        activity_type: "sensitive_file_access".to_string(),
                        severity: "high".to_string(),
                        description: format!("Access to sensitive file: {}", fd.path),
                        evidence: format!("FD {} -> {}", fd.fd, fd.path),
                        timestamp: timestamp.clone(),
                    });
                }
            }
        }

        // Check for high memory usage (potential memory hogging attack)
        if snapshot.memory_usage.rss > 500 * 1024 * 1024 { // > 500MB
            activities.push(SuspiciousActivity {
                activity_type: "high_memory".to_string(),
                severity: "low".to_string(),
                description: "Process using significant memory".to_string(),
                evidence: format!("RSS: {} MB", snapshot.memory_usage.rss / 1024 / 1024),
                timestamp: timestamp.clone(),
            });
        }

        activities
    }

    /// Take a snapshot of the process
    fn take_snapshot(&mut self, pid: i32) -> Result<ProcessSnapshot> {
        let process = self.get_process_info(pid)?;
        let libraries = self.get_loaded_libraries(pid).unwrap_or_default();
        let file_descriptors = self.get_file_descriptors(pid).unwrap_or_default();
        let network_connections = self.get_network_connections(pid).unwrap_or_default();
        let memory_usage = self.get_memory_usage(pid).unwrap_or(MemoryUsage {
            vsize: 0, rss: 0, shared: 0, data: 0,
        });

        let mut snapshot = ProcessSnapshot {
            timestamp: Local::now().format("%Y-%m-%d %H:%M:%S%.3f").to_string(),
            process,
            libraries,
            file_descriptors,
            network_connections,
            memory_usage,
            suspicious_activities: Vec::new(),
        };

        snapshot.suspicious_activities = self.detect_suspicious_activities(&snapshot);

        Ok(snapshot)
    }

    /// Print snapshot to console
    fn print_snapshot(&self, snapshot: &ProcessSnapshot) {
        println!("\n{}", "=".repeat(70).cyan());
        println!("{} - PID: {}",
            snapshot.timestamp.cyan().bold(),
            snapshot.process.pid.to_string().yellow());
        println!("{}", "=".repeat(70).cyan());

        // Process info
        println!("{}", "Process Information:".bold());
        println!("  Name:    {}", snapshot.process.name.green());
        println!("  Command: {}", snapshot.process.cmdline.dimmed());
        println!("  Exe:     {}", snapshot.process.exe_path);
        println!("  CWD:     {}", snapshot.process.cwd);
        println!("  UID:     {} | PPID: {}", snapshot.process.uid, snapshot.process.ppid);

        // Memory
        println!("\n{}", "Memory Usage:".bold());
        println!("  Virtual: {} MB | RSS: {} MB | Shared: {} MB",
            snapshot.memory_usage.vsize / 1024 / 1024,
            snapshot.memory_usage.rss / 1024 / 1024,
            snapshot.memory_usage.shared / 1024 / 1024);

        // Libraries
        if self.args.verbose {
            println!("\n{} ({})", "Loaded Libraries:".bold(), snapshot.libraries.len());
            for lib in &snapshot.libraries {
                let display = if !lib.suspicious_imports.is_empty() {
                    format!("{} [!]", lib.path).red()
                } else {
                    lib.path.normal()
                };
                println!("  {} (0x{:x}, {} bytes)",
                    display, lib.base_addr, lib.size);

                if !lib.suspicious_imports.is_empty() {
                    println!("    {} Suspicious: {}", "->".red(),
                        lib.suspicious_imports.join(", ").yellow());
                }
            }
        } else {
            println!("\n{}: {}", "Loaded Libraries".bold(), snapshot.libraries.len());
        }

        // File descriptors
        if self.args.verbose {
            println!("\n{} ({}):", "Open File Descriptors".bold(), snapshot.file_descriptors.len());
            for fd in &snapshot.file_descriptors {
                println!("  FD {}: [{}] {}", fd.fd, fd.fd_type, fd.path.dimmed());
            }
        } else {
            println!("{}: {}", "Open FDs".bold(), snapshot.file_descriptors.len());
        }

        // Network connections
        if !snapshot.network_connections.is_empty() {
            println!("\n{} ({}):", "Network Connections".bold(),
                snapshot.network_connections.len().to_string().yellow());
            for conn in &snapshot.network_connections {
                let state_color = match conn.state.as_str() {
                    "ESTABLISHED" => conn.state.green(),
                    "LISTEN" => conn.state.yellow(),
                    _ => conn.state.normal(),
                };
                println!("  {} {} -> {} [{}]",
                    conn.protocol.cyan(),
                    conn.local_addr,
                    conn.remote_addr,
                    state_color);
            }
        }

        // Suspicious activities
        if !snapshot.suspicious_activities.is_empty() {
            println!("\n{}", "=".repeat(50).red());
            println!("{}", "SUSPICIOUS ACTIVITIES DETECTED:".red().bold());
            println!("{}", "=".repeat(50).red());

            for activity in &snapshot.suspicious_activities {
                let severity_display = match activity.severity.as_str() {
                    "critical" => activity.severity.on_red().white().bold(),
                    "high" => activity.severity.red().bold(),
                    "medium" => activity.severity.yellow(),
                    _ => activity.severity.normal(),
                };

                println!("\n  [{}] {}", severity_display, activity.activity_type.bold());
                println!("    {}", activity.description);
                println!("    Evidence: {}", activity.evidence.yellow());
            }
        }
    }

    /// Find PIDs by process name
    fn find_pids_by_name(&self, name: &str) -> Result<Vec<i32>> {
        let mut pids = Vec::new();

        for entry in fs::read_dir("/proc")? {
            let entry = entry?;
            if let Ok(pid) = entry.file_name().to_string_lossy().parse::<i32>() {
                let comm_path = format!("/proc/{}/comm", pid);
                if let Ok(comm) = fs::read_to_string(&comm_path) {
                    if comm.trim().contains(name) {
                        pids.push(pid);
                    }
                }
            }
        }

        Ok(pids)
    }

    /// Run the monitor
    fn run(&mut self) -> Result<()> {
        println!("{}", "=".repeat(70).cyan());
        println!("{}", "  API MONITOR - Malware Dynamic Analysis Tool".cyan().bold());
        println!("{}", "  For DEFENSIVE security research only".yellow());
        println!("{}", "=".repeat(70).cyan());

        // Determine which PIDs to monitor
        let pids: Vec<i32> = if let Some(pid) = self.args.pid {
            vec![pid]
        } else if let Some(ref name) = self.args.name {
            self.find_pids_by_name(name)?
        } else {
            // Demo mode - monitor self
            println!("{}", "[*] Demo mode: monitoring self".yellow());
            vec![std::process::id() as i32]
        };

        if pids.is_empty() {
            println!("{}", "[!] No processes found to monitor".red());
            return Ok(());
        }

        println!("{}", format!("[*] Monitoring PIDs: {:?}", pids).green());
        println!("{}", format!("[*] Interval: {}ms, Duration: {}s",
            self.args.interval, self.args.duration).dimmed());

        let start = Instant::now();
        let duration = if self.args.duration > 0 {
            Duration::from_secs(self.args.duration)
        } else {
            Duration::from_secs(3600 * 24) // 24 hours if continuous
        };

        while start.elapsed() < duration {
            for &pid in &pids {
                match self.take_snapshot(pid) {
                    Ok(snapshot) => {
                        // Filter based on suspicious_only flag
                        if !self.args.suspicious_only || !snapshot.suspicious_activities.is_empty() {
                            self.print_snapshot(&snapshot);
                            self.snapshots.push(snapshot);
                        }
                    }
                    Err(e) => {
                        if self.args.verbose {
                            eprintln!("{}", format!("[!] Error monitoring PID {}: {}", pid, e).red());
                        }
                    }
                }
            }

            std::thread::sleep(Duration::from_millis(self.args.interval));
        }

        // Save results if output specified
        if let Some(ref output) = self.args.output {
            self.save_results(output)?;
        }

        self.print_summary();
        Ok(())
    }

    /// Save monitoring results
    fn save_results(&self, path: &str) -> Result<()> {
        let file = File::create(path)?;
        let mut writer = BufWriter::new(file);

        match self.args.format {
            OutputFormat::Json => {
                serde_json::to_writer_pretty(&mut writer, &self.snapshots)?;
            }
            OutputFormat::Csv => {
                writeln!(writer, "timestamp,pid,name,libraries,fds,connections,suspicious_count")?;
                for snap in &self.snapshots {
                    writeln!(writer, "{},{},{},{},{},{},{}",
                        snap.timestamp,
                        snap.process.pid,
                        snap.process.name,
                        snap.libraries.len(),
                        snap.file_descriptors.len(),
                        snap.network_connections.len(),
                        snap.suspicious_activities.len())?;
                }
            }
            OutputFormat::Text => {
                for snap in &self.snapshots {
                    writeln!(writer, "[{}] PID {} ({})",
                        snap.timestamp, snap.process.pid, snap.process.name)?;
                    writeln!(writer, "  Libraries: {}, FDs: {}, Connections: {}",
                        snap.libraries.len(),
                        snap.file_descriptors.len(),
                        snap.network_connections.len())?;
                    if !snap.suspicious_activities.is_empty() {
                        writeln!(writer, "  SUSPICIOUS: {}", snap.suspicious_activities.len())?;
                    }
                    writeln!(writer)?;
                }
            }
        }

        println!("{}", format!("[*] Results saved to: {}", path).green());
        Ok(())
    }

    /// Print summary
    fn print_summary(&self) {
        println!("\n{}", "=".repeat(70).cyan());
        println!("{}", "MONITORING SUMMARY".cyan().bold());
        println!("{}", "=".repeat(70).cyan());

        println!("Total snapshots: {}", self.snapshots.len());

        let total_suspicious: usize = self.snapshots.iter()
            .map(|s| s.suspicious_activities.len())
            .sum();

        if total_suspicious > 0 {
            println!("{}", format!("Total suspicious activities: {}", total_suspicious).red().bold());
        } else {
            println!("{}", "No suspicious activities detected".green());
        }
    }
}

fn main() -> Result<()> {
    let args = Args::parse();
    let mut monitor = ApiMonitor::new(args);
    monitor.run()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_hex_address_parsing() {
        let monitor = ApiMonitor::new(Args::parse_from(["test"]));
        let addr = monitor.parse_hex_address("0100007F:1F90");
        assert!(addr.is_some());
        assert!(addr.unwrap().contains("127.0.0.1"));
    }

    #[test]
    fn test_tcp_state_parsing() {
        let monitor = ApiMonitor::new(Args::parse_from(["test"]));
        assert_eq!(monitor.parse_tcp_state("01"), "ESTABLISHED");
        assert_eq!(monitor.parse_tcp_state("0A"), "LISTEN");
    }
}
