//! # RT04 Credential Harvester
//!
//! A post-exploitation credential parsing tool for authorized security assessments.
//! This tool scans for and parses common credential storage locations including:
//! - Configuration files
//! - Browser stored credentials
//! - SSH keys
//! - Database connection strings
//! - Cloud provider credentials
//! - Application secrets
//!
//! ## Legal Disclaimer
//!
//! THIS TOOL IS PROVIDED FOR AUTHORIZED SECURITY TESTING ONLY.
//! Accessing credentials without authorization is illegal. This tool
//! should only be used during authorized penetration tests or on
//! systems you own. The authors assume no liability for misuse.
//!
//! ## Usage Examples
//!
//! ```bash
//! # Scan current directory for credentials
//! cred-harvest --path /home/user
//!
//! # Scan with specific types
//! cred-harvest --path /var/www --types config,env
//!
//! # Output to JSON file
//! cred-harvest --path /home/user -o credentials.json
//! ```

use anyhow::{Context, Result};
use clap::{Parser, ValueEnum};
use colored::*;
use configparser::ini::Ini;
use regex::Regex;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::fs::{self, File};
use std::io::{BufRead, BufReader, Write};
use std::path::{Path, PathBuf};
use walkdir::WalkDir;

// ============================================================================
// LEGAL DISCLAIMER
// ============================================================================

const LEGAL_DISCLAIMER: &str = r#"
╔══════════════════════════════════════════════════════════════════════════════╗
║                           LEGAL DISCLAIMER                                    ║
╠══════════════════════════════════════════════════════════════════════════════╣
║  This tool is provided for AUTHORIZED SECURITY ASSESSMENTS ONLY.             ║
║                                                                              ║
║  By using this tool, you acknowledge that:                                   ║
║  1. You have explicit written authorization to access these credentials      ║
║  2. Unauthorized access to credentials is a criminal offense                 ║
║  3. You accept full responsibility for your actions                          ║
║  4. The authors are not liable for any misuse or damage caused               ║
║                                                                              ║
║  Credential harvesting without permission may violate:                       ║
║  - Computer Fraud and Abuse Act (CFAA)                                       ║
║  - Privacy laws and regulations                                              ║
║  - Data protection regulations (GDPR, etc.)                                  ║
╚══════════════════════════════════════════════════════════════════════════════╝
"#;

// ============================================================================
// COMMAND LINE INTERFACE
// ============================================================================

/// Credential Harvester for Authorized Security Assessments
#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    /// Path to scan for credentials
    #[arg(short, long, default_value = ".")]
    path: PathBuf,

    /// Types of credentials to search for (comma-separated)
    #[arg(short, long, default_value = "all")]
    types: String,

    /// Maximum directory depth to scan
    #[arg(short, long, default_value = "10")]
    depth: usize,

    /// Output file for JSON results
    #[arg(short, long)]
    output: Option<PathBuf>,

    /// Skip legal disclaimer
    #[arg(long)]
    accept_disclaimer: bool,

    /// Verbose output
    #[arg(short, long)]
    verbose: bool,

    /// Include file contents in output (WARNING: may contain secrets)
    #[arg(long)]
    include_contents: bool,

    /// Maximum file size to scan (in KB)
    #[arg(long, default_value = "1024")]
    max_size_kb: u64,
}

/// Types of credentials to search for
#[derive(Debug, Clone, Copy, PartialEq, Eq, ValueEnum)]
enum CredentialType {
    /// Environment files (.env)
    Env,
    /// Configuration files
    Config,
    /// SSH keys
    Ssh,
    /// Cloud provider credentials
    Cloud,
    /// Database credentials
    Database,
    /// Browser credentials
    Browser,
    /// History files
    History,
    /// All types
    All,
}

// ============================================================================
// DATA STRUCTURES
// ============================================================================

/// Represents a discovered credential
#[derive(Debug, Clone, Serialize, Deserialize)]
struct Credential {
    /// Type of credential
    credential_type: String,
    /// Source file path
    source: String,
    /// Credential key/name
    key: String,
    /// Credential value (redacted by default)
    value: String,
    /// Risk level (high, medium, low)
    risk_level: String,
    /// Additional context
    context: Option<String>,
}

/// Credential scan results
#[derive(Debug, Serialize, Deserialize)]
struct ScanReport {
    /// Scan timestamp
    timestamp: String,
    /// Scanned path
    scanned_path: String,
    /// Total files scanned
    files_scanned: usize,
    /// Total credentials found
    credentials_found: usize,
    /// Credentials grouped by type
    credentials: Vec<Credential>,
    /// Interesting files found
    interesting_files: Vec<String>,
}

// ============================================================================
// CREDENTIAL PATTERNS
// ============================================================================

/// Patterns for detecting credentials in files
struct CredentialPatterns {
    /// Environment variable patterns
    env_patterns: Vec<(Regex, &'static str, &'static str)>,
    /// Secret patterns (API keys, tokens, etc.)
    secret_patterns: Vec<(Regex, &'static str, &'static str)>,
    /// Connection string patterns
    connection_patterns: Vec<(Regex, &'static str, &'static str)>,
}

impl CredentialPatterns {
    fn new() -> Result<Self> {
        Ok(Self {
            env_patterns: vec![
                (Regex::new(r"(?i)(password|passwd|pwd)\s*[=:]\s*['\"]?([^'\"\s]+)")?,
                 "password", "high"),
                (Regex::new(r"(?i)(api[_-]?key|apikey)\s*[=:]\s*['\"]?([^'\"\s]+)")?,
                 "api_key", "high"),
                (Regex::new(r"(?i)(secret[_-]?key|secretkey)\s*[=:]\s*['\"]?([^'\"\s]+)")?,
                 "secret_key", "high"),
                (Regex::new(r"(?i)(access[_-]?token|accesstoken)\s*[=:]\s*['\"]?([^'\"\s]+)")?,
                 "access_token", "high"),
                (Regex::new(r"(?i)(auth[_-]?token|authtoken)\s*[=:]\s*['\"]?([^'\"\s]+)")?,
                 "auth_token", "high"),
                (Regex::new(r"(?i)(private[_-]?key|privatekey)\s*[=:]\s*['\"]?([^'\"\s]+)")?,
                 "private_key", "high"),
                (Regex::new(r"(?i)(db[_-]?password|database[_-]?password)\s*[=:]\s*['\"]?([^'\"\s]+)")?,
                 "db_password", "high"),
                (Regex::new(r"(?i)(username|user)\s*[=:]\s*['\"]?([^'\"\s]+)")?,
                 "username", "medium"),
                (Regex::new(r"(?i)(host|hostname|server)\s*[=:]\s*['\"]?([^'\"\s]+)")?,
                 "host", "low"),
            ],
            secret_patterns: vec![
                // AWS credentials
                (Regex::new(r"(?i)AKIA[0-9A-Z]{16}")?,
                 "aws_access_key", "high"),
                (Regex::new(r"(?i)aws[_-]?secret[_-]?access[_-]?key\s*[=:]\s*['\"]?([A-Za-z0-9/+=]{40})")?,
                 "aws_secret_key", "high"),
                // GitHub tokens
                (Regex::new(r"ghp_[A-Za-z0-9]{36}")?,
                 "github_personal_token", "high"),
                (Regex::new(r"gho_[A-Za-z0-9]{36}")?,
                 "github_oauth_token", "high"),
                (Regex::new(r"ghu_[A-Za-z0-9]{36}")?,
                 "github_user_token", "high"),
                // Slack tokens
                (Regex::new(r"xox[baprs]-[0-9a-zA-Z]{10,48}")?,
                 "slack_token", "high"),
                // Stripe keys
                (Regex::new(r"sk_live_[0-9a-zA-Z]{24}")?,
                 "stripe_secret_key", "high"),
                (Regex::new(r"pk_live_[0-9a-zA-Z]{24}")?,
                 "stripe_public_key", "medium"),
                // JWT tokens
                (Regex::new(r"eyJ[A-Za-z0-9_-]+\.eyJ[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+")?,
                 "jwt_token", "high"),
                // Private keys
                (Regex::new(r"-----BEGIN\s+(RSA|DSA|EC|OPENSSH)?\s*PRIVATE KEY-----")?,
                 "private_key_header", "high"),
                // Google API keys
                (Regex::new(r"AIza[0-9A-Za-z_-]{35}")?,
                 "google_api_key", "high"),
                // Heroku API key
                (Regex::new(r"(?i)heroku[_-]?api[_-]?key\s*[=:]\s*['\"]?([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})")?,
                 "heroku_api_key", "high"),
            ],
            connection_patterns: vec![
                // Database connection strings
                (Regex::new(r"(?i)mysql://([^:]+):([^@]+)@([^/]+)/(\w+)")?,
                 "mysql_connection", "high"),
                (Regex::new(r"(?i)postgres(ql)?://([^:]+):([^@]+)@([^/]+)/(\w+)")?,
                 "postgres_connection", "high"),
                (Regex::new(r"(?i)mongodb(\+srv)?://([^:]+):([^@]+)@([^/]+)")?,
                 "mongodb_connection", "high"),
                (Regex::new(r"(?i)redis://([^:]+):([^@]+)@([^/]+)")?,
                 "redis_connection", "high"),
                // SMTP credentials
                (Regex::new(r"(?i)smtp://([^:]+):([^@]+)@([^/]+)")?,
                 "smtp_connection", "high"),
            ],
        })
    }
}

// ============================================================================
// CREDENTIAL SCANNER
// ============================================================================

/// Main credential scanning functionality
struct CredentialScanner {
    patterns: CredentialPatterns,
    config: ScanConfig,
    credentials: Vec<Credential>,
    interesting_files: Vec<String>,
    files_scanned: usize,
}

/// Scanner configuration
struct ScanConfig {
    verbose: bool,
    include_contents: bool,
    max_file_size: u64,
    scan_types: Vec<String>,
}

impl CredentialScanner {
    fn new(config: ScanConfig) -> Result<Self> {
        Ok(Self {
            patterns: CredentialPatterns::new()?,
            config,
            credentials: Vec::new(),
            interesting_files: Vec::new(),
            files_scanned: 0,
        })
    }

    /// Scan a directory for credentials
    fn scan_directory(&mut self, path: &Path, max_depth: usize) -> Result<()> {
        println!("{} Scanning directory: {:?}", "[*]".blue(), path);

        for entry in WalkDir::new(path)
            .max_depth(max_depth)
            .follow_links(false)
            .into_iter()
            .filter_map(|e| e.ok())
        {
            let path = entry.path();

            // Skip directories
            if path.is_dir() {
                continue;
            }

            // Check file size
            if let Ok(metadata) = fs::metadata(path) {
                if metadata.len() > self.config.max_file_size {
                    continue;
                }
            }

            // Determine file type and scan appropriately
            self.scan_file(path)?;
        }

        Ok(())
    }

    /// Scan a single file for credentials
    fn scan_file(&mut self, path: &Path) -> Result<()> {
        let filename = path.file_name()
            .and_then(|n| n.to_str())
            .unwrap_or("");

        let extension = path.extension()
            .and_then(|e| e.to_str())
            .unwrap_or("");

        // Check for interesting files
        if self.is_interesting_file(filename, extension) {
            self.interesting_files.push(path.to_string_lossy().to_string());
        }

        // Environment files
        if self.should_scan_type("env") && self.is_env_file(filename) {
            self.scan_env_file(path)?;
        }

        // Configuration files
        if self.should_scan_type("config") && self.is_config_file(filename, extension) {
            self.scan_config_file(path)?;
        }

        // SSH keys
        if self.should_scan_type("ssh") && self.is_ssh_file(path) {
            self.scan_ssh_file(path)?;
        }

        // Cloud credentials
        if self.should_scan_type("cloud") && self.is_cloud_file(path, filename) {
            self.scan_cloud_file(path)?;
        }

        // History files
        if self.should_scan_type("history") && self.is_history_file(filename) {
            self.scan_history_file(path)?;
        }

        // General pattern matching for source code
        if self.is_source_file(extension) {
            self.scan_source_file(path)?;
        }

        self.files_scanned += 1;
        Ok(())
    }

    /// Check if we should scan a particular type
    fn should_scan_type(&self, type_name: &str) -> bool {
        self.config.scan_types.contains(&"all".to_string()) ||
        self.config.scan_types.contains(&type_name.to_string())
    }

    /// Check if file is an environment file
    fn is_env_file(&self, filename: &str) -> bool {
        filename == ".env" ||
        filename.starts_with(".env.") ||
        filename.ends_with(".env")
    }

    /// Check if file is a configuration file
    fn is_config_file(&self, filename: &str, extension: &str) -> bool {
        let config_extensions = ["ini", "cfg", "conf", "config", "yaml", "yml", "toml", "json", "xml"];
        let config_names = [
            "config", "settings", "credentials", "secrets", "database",
            "application", "appsettings", "web.config", "app.config",
        ];

        config_extensions.contains(&extension) ||
        config_names.iter().any(|n| filename.to_lowercase().contains(n))
    }

    /// Check if file is an SSH-related file
    fn is_ssh_file(&self, path: &Path) -> bool {
        let path_str = path.to_string_lossy().to_lowercase();
        path_str.contains(".ssh") ||
        path_str.ends_with("id_rsa") ||
        path_str.ends_with("id_dsa") ||
        path_str.ends_with("id_ecdsa") ||
        path_str.ends_with("id_ed25519") ||
        path_str.ends_with("known_hosts") ||
        path_str.ends_with("authorized_keys")
    }

    /// Check if file is a cloud credential file
    fn is_cloud_file(&self, path: &Path, filename: &str) -> bool {
        let path_str = path.to_string_lossy().to_lowercase();
        filename == "credentials" ||
        filename == "config" && path_str.contains(".aws") ||
        filename == "credentials.json" ||
        filename == "service_account.json" ||
        path_str.contains(".azure") ||
        path_str.contains("gcloud")
    }

    /// Check if file is a history file
    fn is_history_file(&self, filename: &str) -> bool {
        filename.contains("history") ||
        filename == ".bash_history" ||
        filename == ".zsh_history" ||
        filename == ".python_history" ||
        filename == ".mysql_history" ||
        filename == ".psql_history"
    }

    /// Check if file is a source code file
    fn is_source_file(&self, extension: &str) -> bool {
        let source_extensions = [
            "py", "js", "ts", "rb", "php", "java", "go", "rs", "c", "cpp",
            "cs", "swift", "kt", "scala", "sh", "bash", "ps1", "sql",
        ];
        source_extensions.contains(&extension)
    }

    /// Check if file is interesting for security review
    fn is_interesting_file(&self, filename: &str, _extension: &str) -> bool {
        let interesting_names = [
            "id_rsa", "id_dsa", "id_ecdsa", "id_ed25519",
            "credentials", "secrets", "password", "private",
            "shadow", "passwd", "htpasswd", "pgpass",
            ".npmrc", ".pypirc", ".netrc", ".docker",
        ];

        interesting_names.iter().any(|n| filename.contains(n))
    }

    /// Scan environment file
    fn scan_env_file(&mut self, path: &Path) -> Result<()> {
        if self.config.verbose {
            println!("{} Scanning env file: {:?}", "[*]".blue(), path);
        }

        let content = fs::read_to_string(path)?;

        for line in content.lines() {
            let line = line.trim();

            // Skip comments and empty lines
            if line.is_empty() || line.starts_with('#') {
                continue;
            }

            // Parse KEY=VALUE format
            if let Some(pos) = line.find('=') {
                let key = &line[..pos].trim();
                let value = &line[pos + 1..].trim().trim_matches('"').trim_matches('\'');

                // Check if this looks like a credential
                let key_lower = key.to_lowercase();
                let risk_level = if key_lower.contains("password") ||
                                    key_lower.contains("secret") ||
                                    key_lower.contains("token") ||
                                    key_lower.contains("key") {
                    "high"
                } else if key_lower.contains("user") ||
                          key_lower.contains("host") {
                    "medium"
                } else {
                    continue; // Skip non-credential looking entries
                };

                self.add_credential(
                    "env_variable",
                    path,
                    key,
                    value,
                    risk_level,
                    None,
                );
            }
        }

        Ok(())
    }

    /// Scan configuration file
    fn scan_config_file(&mut self, path: &Path) -> Result<()> {
        if self.config.verbose {
            println!("{} Scanning config file: {:?}", "[*]".blue(), path);
        }

        let content = match fs::read_to_string(path) {
            Ok(c) => c,
            Err(_) => return Ok(()), // Skip binary files
        };

        // Apply pattern matching
        self.apply_patterns(&content, path)?;

        // Try to parse as specific format
        let extension = path.extension()
            .and_then(|e| e.to_str())
            .unwrap_or("");

        match extension {
            "ini" | "cfg" | "conf" => self.parse_ini_config(path)?,
            "yaml" | "yml" => self.parse_yaml_config(&content, path)?,
            "json" => self.parse_json_config(&content, path)?,
            "toml" => self.parse_toml_config(&content, path)?,
            _ => {}
        }

        Ok(())
    }

    /// Parse INI-style configuration
    fn parse_ini_config(&mut self, path: &Path) -> Result<()> {
        let mut config = Ini::new();
        if config.load(path.to_string_lossy().as_ref()).is_err() {
            return Ok(());
        }

        for section in config.sections() {
            for (key, value) in config.get_map_ref().get(&section).unwrap_or(&HashMap::new()) {
                if let Some(val) = value {
                    let key_lower = key.to_lowercase();
                    if key_lower.contains("password") ||
                       key_lower.contains("secret") ||
                       key_lower.contains("token") ||
                       key_lower.contains("key") {
                        self.add_credential(
                            "ini_config",
                            path,
                            key,
                            val,
                            "high",
                            Some(&format!("Section: {}", section)),
                        );
                    }
                }
            }
        }

        Ok(())
    }

    /// Parse YAML configuration
    fn parse_yaml_config(&mut self, content: &str, path: &Path) -> Result<()> {
        // Simple YAML pattern matching - full parsing would require more complex handling
        self.apply_patterns(content, path)
    }

    /// Parse JSON configuration
    fn parse_json_config(&mut self, content: &str, path: &Path) -> Result<()> {
        if let Ok(value) = serde_json::from_str::<serde_json::Value>(content) {
            self.search_json_value(&value, path, "");
        }
        Ok(())
    }

    /// Recursively search JSON value for credentials
    fn search_json_value(&mut self, value: &serde_json::Value, path: &Path, prefix: &str) {
        match value {
            serde_json::Value::Object(map) => {
                for (key, val) in map {
                    let full_key = if prefix.is_empty() {
                        key.clone()
                    } else {
                        format!("{}.{}", prefix, key)
                    };

                    let key_lower = key.to_lowercase();
                    if key_lower.contains("password") ||
                       key_lower.contains("secret") ||
                       key_lower.contains("token") ||
                       key_lower.contains("key") ||
                       key_lower.contains("credential") {
                        if let Some(s) = val.as_str() {
                            self.add_credential(
                                "json_config",
                                path,
                                &full_key,
                                s,
                                "high",
                                None,
                            );
                        }
                    }

                    self.search_json_value(val, path, &full_key);
                }
            }
            serde_json::Value::Array(arr) => {
                for (i, val) in arr.iter().enumerate() {
                    self.search_json_value(val, path, &format!("{}[{}]", prefix, i));
                }
            }
            _ => {}
        }
    }

    /// Parse TOML configuration
    fn parse_toml_config(&mut self, content: &str, path: &Path) -> Result<()> {
        // Apply pattern matching to TOML content
        self.apply_patterns(content, path)
    }

    /// Scan SSH-related file
    fn scan_ssh_file(&mut self, path: &Path) -> Result<()> {
        if self.config.verbose {
            println!("{} Scanning SSH file: {:?}", "[*]".blue(), path);
        }

        let content = match fs::read_to_string(path) {
            Ok(c) => c,
            Err(_) => return Ok(()),
        };

        // Check for private key headers
        if content.contains("-----BEGIN") && content.contains("PRIVATE KEY-----") {
            let key_type = if content.contains("RSA") {
                "RSA"
            } else if content.contains("DSA") {
                "DSA"
            } else if content.contains("EC") {
                "ECDSA"
            } else if content.contains("OPENSSH") {
                "OpenSSH"
            } else {
                "Unknown"
            };

            let encrypted = content.contains("ENCRYPTED");

            self.add_credential(
                "ssh_private_key",
                path,
                &format!("{} Private Key", key_type),
                if encrypted { "[ENCRYPTED]" } else { "[UNENCRYPTED]" },
                if encrypted { "medium" } else { "high" },
                Some(&format!("Encrypted: {}", encrypted)),
            );
        }

        Ok(())
    }

    /// Scan cloud credential file
    fn scan_cloud_file(&mut self, path: &Path) -> Result<()> {
        if self.config.verbose {
            println!("{} Scanning cloud file: {:?}", "[*]".blue(), path);
        }

        let content = fs::read_to_string(path)?;

        // Apply all patterns
        self.apply_patterns(&content, path)?;

        // AWS credentials format
        if path.to_string_lossy().contains(".aws") {
            self.parse_ini_config(path)?;
        }

        // GCP service account
        if path.to_string_lossy().contains("service_account") ||
           path.to_string_lossy().contains("credentials.json") {
            if let Ok(value) = serde_json::from_str::<serde_json::Value>(&content) {
                if value.get("type").and_then(|v| v.as_str()) == Some("service_account") {
                    if let Some(email) = value.get("client_email").and_then(|v| v.as_str()) {
                        self.add_credential(
                            "gcp_service_account",
                            path,
                            "client_email",
                            email,
                            "high",
                            Some("GCP Service Account JSON"),
                        );
                    }
                }
            }
        }

        Ok(())
    }

    /// Scan history file
    fn scan_history_file(&mut self, path: &Path) -> Result<()> {
        if self.config.verbose {
            println!("{} Scanning history file: {:?}", "[*]".blue(), path);
        }

        let file = File::open(path)?;
        let reader = BufReader::new(file);

        for line in reader.lines().take(10000) { // Limit lines to prevent memory issues
            if let Ok(line) = line {
                // Look for commands with potential credentials
                if line.contains("password") ||
                   line.contains("--password") ||
                   line.contains("-p ") ||
                   line.contains("curl") && line.contains("-u") ||
                   line.contains("mysql") ||
                   line.contains("psql") {
                    self.add_credential(
                        "history_command",
                        path,
                        "command",
                        &line,
                        "medium",
                        Some("Command from history file"),
                    );
                }
            }
        }

        Ok(())
    }

    /// Scan source code file for hardcoded credentials
    fn scan_source_file(&mut self, path: &Path) -> Result<()> {
        let content = match fs::read_to_string(path) {
            Ok(c) => c,
            Err(_) => return Ok(()),
        };

        self.apply_patterns(&content, path)
    }

    /// Apply all credential patterns to content
    fn apply_patterns(&mut self, content: &str, path: &Path) -> Result<()> {
        // Environment patterns
        for (regex, name, risk) in &self.patterns.env_patterns {
            for caps in regex.captures_iter(content) {
                if let Some(value) = caps.get(2).or(caps.get(1)) {
                    let key = caps.get(1).map_or("", |m| m.as_str());
                    self.add_credential(
                        name,
                        path,
                        key,
                        value.as_str(),
                        risk,
                        None,
                    );
                }
            }
        }

        // Secret patterns (API keys, tokens, etc.)
        for (regex, name, risk) in &self.patterns.secret_patterns {
            for caps in regex.captures_iter(content) {
                let matched = caps.get(1).or(caps.get(0))
                    .map_or("", |m| m.as_str());
                self.add_credential(
                    name,
                    path,
                    name,
                    matched,
                    risk,
                    None,
                );
            }
        }

        // Connection strings
        for (regex, name, risk) in &self.patterns.connection_patterns {
            for caps in regex.captures_iter(content) {
                let matched = caps.get(0).map_or("", |m| m.as_str());
                self.add_credential(
                    name,
                    path,
                    name,
                    matched,
                    risk,
                    Some("Database connection string"),
                );
            }
        }

        Ok(())
    }

    /// Add a discovered credential
    fn add_credential(
        &mut self,
        cred_type: &str,
        path: &Path,
        key: &str,
        value: &str,
        risk: &str,
        context: Option<&str>,
    ) {
        // Redact value unless include_contents is set
        let display_value = if self.config.include_contents {
            value.to_string()
        } else {
            Self::redact_value(value)
        };

        let credential = Credential {
            credential_type: cred_type.to_string(),
            source: path.to_string_lossy().to_string(),
            key: key.to_string(),
            value: display_value,
            risk_level: risk.to_string(),
            context: context.map(String::from),
        };

        // Avoid duplicates
        if !self.credentials.iter().any(|c|
            c.source == credential.source &&
            c.key == credential.key &&
            c.credential_type == credential.credential_type
        ) {
            self.credentials.push(credential);
        }
    }

    /// Redact credential value for safe display
    fn redact_value(value: &str) -> String {
        if value.len() <= 4 {
            "*".repeat(value.len())
        } else {
            format!("{}...{}", &value[..2], &value[value.len()-2..])
        }
    }

    /// Generate scan report
    fn generate_report(&self, scanned_path: &Path) -> ScanReport {
        ScanReport {
            timestamp: chrono::Utc::now().to_rfc3339(),
            scanned_path: scanned_path.to_string_lossy().to_string(),
            files_scanned: self.files_scanned,
            credentials_found: self.credentials.len(),
            credentials: self.credentials.clone(),
            interesting_files: self.interesting_files.clone(),
        }
    }
}

// ============================================================================
// OUTPUT FUNCTIONS
// ============================================================================

/// Display scan results
fn display_results(report: &ScanReport) {
    println!("\n{}", "═".repeat(80).cyan());
    println!("{}", " CREDENTIAL SCAN RESULTS ".cyan().bold());
    println!("{}", "═".repeat(80).cyan());

    println!("\n{}", "Summary:".white().bold());
    println!("    {} {}", "Scanned Path:".dimmed(), report.scanned_path);
    println!("    {} {}", "Files Scanned:".dimmed(), report.files_scanned);
    println!("    {} {}", "Credentials Found:".dimmed(), report.credentials_found);

    if !report.credentials.is_empty() {
        println!("\n{}", "Discovered Credentials:".white().bold());

        // Group by risk level
        let high_risk: Vec<_> = report.credentials.iter()
            .filter(|c| c.risk_level == "high")
            .collect();
        let medium_risk: Vec<_> = report.credentials.iter()
            .filter(|c| c.risk_level == "medium")
            .collect();

        if !high_risk.is_empty() {
            println!("\n  {} HIGH RISK:", "[!]".red().bold());
            for cred in high_risk {
                println!("    {} {} = {} ({})",
                    "[+]".green(),
                    cred.key.yellow(),
                    cred.value.red(),
                    cred.credential_type.dimmed());
                println!("        Source: {}", cred.source.dimmed());
                if let Some(ctx) = &cred.context {
                    println!("        Context: {}", ctx.dimmed());
                }
            }
        }

        if !medium_risk.is_empty() {
            println!("\n  {} MEDIUM RISK:", "[!]".yellow().bold());
            for cred in medium_risk {
                println!("    {} {} = {} ({})",
                    "[*]".blue(),
                    cred.key.yellow(),
                    cred.value,
                    cred.credential_type.dimmed());
                println!("        Source: {}", cred.source.dimmed());
            }
        }
    }

    if !report.interesting_files.is_empty() {
        println!("\n{}", "Interesting Files:".white().bold());
        for file in &report.interesting_files {
            println!("    {} {}", "[*]".blue(), file);
        }
    }

    println!("\n{}", "═".repeat(80).cyan());
}

/// Save results to JSON file
fn save_results(report: &ScanReport, output: PathBuf) -> Result<()> {
    let mut file = File::create(&output)
        .with_context(|| format!("Failed to create output file: {:?}", output))?;

    let json = serde_json::to_string_pretty(report)?;
    file.write_all(json.as_bytes())?;

    println!("{} Results saved to {:?}", "[+]".green(), output);
    Ok(())
}

// ============================================================================
// MAIN ENTRY POINT
// ============================================================================

fn main() -> Result<()> {
    // Parse arguments
    let args = Args::parse();

    // Display legal disclaimer
    println!("{}", LEGAL_DISCLAIMER.red());

    if !args.accept_disclaimer {
        println!("{}", "Do you have authorization to scan for credentials? (yes/no): ".yellow());
        let mut input = String::new();
        std::io::stdin().read_line(&mut input)?;

        if input.trim().to_lowercase() != "yes" {
            println!("{} Exiting - authorization required", "[!]".red());
            return Ok(());
        }
    }

    // Parse scan types
    let scan_types: Vec<String> = args.types
        .split(',')
        .map(|s| s.trim().to_lowercase())
        .collect();

    println!("\n{}", "═".repeat(80).cyan());
    println!("{} {:?}", " SCAN PATH:".cyan().bold(), args.path);
    println!("{}", "═".repeat(80).cyan());

    // Create scanner
    let config = ScanConfig {
        verbose: args.verbose,
        include_contents: args.include_contents,
        max_file_size: args.max_size_kb * 1024,
        scan_types,
    };

    let mut scanner = CredentialScanner::new(config)?;

    // Run scan
    scanner.scan_directory(&args.path, args.depth)?;

    // Generate and display report
    let report = scanner.generate_report(&args.path);
    display_results(&report);

    // Save to file if requested
    if let Some(output) = args.output {
        save_results(&report, output)?;
    }

    println!("\n{} Scan complete!", "[+]".green().bold());

    Ok(())
}

// ============================================================================
// TESTS
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_credential_patterns() {
        let patterns = CredentialPatterns::new().unwrap();
        assert!(!patterns.env_patterns.is_empty());
        assert!(!patterns.secret_patterns.is_empty());
    }

    #[test]
    fn test_redact_value() {
        assert_eq!(CredentialScanner::redact_value("password123"), "pa...23");
        assert_eq!(CredentialScanner::redact_value("abc"), "***");
    }

    #[test]
    fn test_aws_key_pattern() {
        let patterns = CredentialPatterns::new().unwrap();
        let aws_pattern = &patterns.secret_patterns[0].0; // AWS access key pattern
        assert!(aws_pattern.is_match("AKIAIOSFODNN7EXAMPLE"));
    }

    #[test]
    fn test_jwt_pattern() {
        let patterns = CredentialPatterns::new().unwrap();
        let jwt_pattern = patterns.secret_patterns.iter()
            .find(|(_, name, _)| *name == "jwt_token")
            .unwrap();
        let sample_jwt = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIn0.dozjgNryP4J3jVmNHl0w5N_XgL0n3I9PlFUP0THsR8U";
        assert!(jwt_pattern.0.is_match(sample_jwt));
    }
}
